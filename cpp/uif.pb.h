// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: uif.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_uif_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_uif_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_uif_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_uif_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[32]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_uif_2eproto;
namespace uif {
class Brush;
struct BrushDefaultTypeInternal;
extern BrushDefaultTypeInternal _Brush_default_instance_;
class ClipRectNode;
struct ClipRectNodeDefaultTypeInternal;
extern ClipRectNodeDefaultTypeInternal _ClipRectNode_default_instance_;
class CloseEvent;
struct CloseEventDefaultTypeInternal;
extern CloseEventDefaultTypeInternal _CloseEvent_default_instance_;
class EditCommand;
struct EditCommandDefaultTypeInternal;
extern EditCommandDefaultTypeInternal _EditCommand_default_instance_;
class EditReq;
struct EditReqDefaultTypeInternal;
extern EditReqDefaultTypeInternal _EditReq_default_instance_;
class EditResp;
struct EditRespDefaultTypeInternal;
extern EditRespDefaultTypeInternal _EditResp_default_instance_;
class EmptyNode;
struct EmptyNodeDefaultTypeInternal;
extern EmptyNodeDefaultTypeInternal _EmptyNode_default_instance_;
class Event;
struct EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class GetEventsReq;
struct GetEventsReqDefaultTypeInternal;
extern GetEventsReqDefaultTypeInternal _GetEventsReq_default_instance_;
class GetServerPropertiesReq;
struct GetServerPropertiesReqDefaultTypeInternal;
extern GetServerPropertiesReqDefaultTypeInternal _GetServerPropertiesReq_default_instance_;
class GetServerPropertiesResp;
struct GetServerPropertiesRespDefaultTypeInternal;
extern GetServerPropertiesRespDefaultTypeInternal _GetServerPropertiesResp_default_instance_;
class GradientStop;
struct GradientStopDefaultTypeInternal;
extern GradientStopDefaultTypeInternal _GradientStop_default_instance_;
class KeyboardEvent;
struct KeyboardEventDefaultTypeInternal;
extern KeyboardEventDefaultTypeInternal _KeyboardEvent_default_instance_;
class LinearGradientBrush;
struct LinearGradientBrushDefaultTypeInternal;
extern LinearGradientBrushDefaultTypeInternal _LinearGradientBrush_default_instance_;
class MouseEvent;
struct MouseEventDefaultTypeInternal;
extern MouseEventDefaultTypeInternal _MouseEvent_default_instance_;
class PCArc;
struct PCArcDefaultTypeInternal;
extern PCArcDefaultTypeInternal _PCArc_default_instance_;
class PCBegin;
struct PCBeginDefaultTypeInternal;
extern PCBeginDefaultTypeInternal _PCBegin_default_instance_;
class PCCubicCurve;
struct PCCubicCurveDefaultTypeInternal;
extern PCCubicCurveDefaultTypeInternal _PCCubicCurve_default_instance_;
class PCEnd;
struct PCEndDefaultTypeInternal;
extern PCEndDefaultTypeInternal _PCEnd_default_instance_;
class PCLineTo;
struct PCLineToDefaultTypeInternal;
extern PCLineToDefaultTypeInternal _PCLineTo_default_instance_;
class PCQuadraticCurve;
struct PCQuadraticCurveDefaultTypeInternal;
extern PCQuadraticCurveDefaultTypeInternal _PCQuadraticCurve_default_instance_;
class PathCommand;
struct PathCommandDefaultTypeInternal;
extern PathCommandDefaultTypeInternal _PathCommand_default_instance_;
class PathNode;
struct PathNodeDefaultTypeInternal;
extern PathNodeDefaultTypeInternal _PathNode_default_instance_;
class Point;
struct PointDefaultTypeInternal;
extern PointDefaultTypeInternal _Point_default_instance_;
class Rectangle;
struct RectangleDefaultTypeInternal;
extern RectangleDefaultTypeInternal _Rectangle_default_instance_;
class RectangleNode;
struct RectangleNodeDefaultTypeInternal;
extern RectangleNodeDefaultTypeInternal _RectangleNode_default_instance_;
class SetClearColorReq;
struct SetClearColorReqDefaultTypeInternal;
extern SetClearColorReqDefaultTypeInternal _SetClearColorReq_default_instance_;
class SetClearColorResp;
struct SetClearColorRespDefaultTypeInternal;
extern SetClearColorRespDefaultTypeInternal _SetClearColorResp_default_instance_;
class SolidBrush;
struct SolidBrushDefaultTypeInternal;
extern SolidBrushDefaultTypeInternal _SolidBrush_default_instance_;
class TextEditSpan;
struct TextEditSpanDefaultTypeInternal;
extern TextEditSpanDefaultTypeInternal _TextEditSpan_default_instance_;
class TextHitEvent;
struct TextHitEventDefaultTypeInternal;
extern TextHitEventDefaultTypeInternal _TextHitEvent_default_instance_;
class TextNode;
struct TextNodeDefaultTypeInternal;
extern TextNodeDefaultTypeInternal _TextNode_default_instance_;
}  // namespace uif
PROTOBUF_NAMESPACE_OPEN
template<> ::uif::Brush* Arena::CreateMaybeMessage<::uif::Brush>(Arena*);
template<> ::uif::ClipRectNode* Arena::CreateMaybeMessage<::uif::ClipRectNode>(Arena*);
template<> ::uif::CloseEvent* Arena::CreateMaybeMessage<::uif::CloseEvent>(Arena*);
template<> ::uif::EditCommand* Arena::CreateMaybeMessage<::uif::EditCommand>(Arena*);
template<> ::uif::EditReq* Arena::CreateMaybeMessage<::uif::EditReq>(Arena*);
template<> ::uif::EditResp* Arena::CreateMaybeMessage<::uif::EditResp>(Arena*);
template<> ::uif::EmptyNode* Arena::CreateMaybeMessage<::uif::EmptyNode>(Arena*);
template<> ::uif::Event* Arena::CreateMaybeMessage<::uif::Event>(Arena*);
template<> ::uif::GetEventsReq* Arena::CreateMaybeMessage<::uif::GetEventsReq>(Arena*);
template<> ::uif::GetServerPropertiesReq* Arena::CreateMaybeMessage<::uif::GetServerPropertiesReq>(Arena*);
template<> ::uif::GetServerPropertiesResp* Arena::CreateMaybeMessage<::uif::GetServerPropertiesResp>(Arena*);
template<> ::uif::GradientStop* Arena::CreateMaybeMessage<::uif::GradientStop>(Arena*);
template<> ::uif::KeyboardEvent* Arena::CreateMaybeMessage<::uif::KeyboardEvent>(Arena*);
template<> ::uif::LinearGradientBrush* Arena::CreateMaybeMessage<::uif::LinearGradientBrush>(Arena*);
template<> ::uif::MouseEvent* Arena::CreateMaybeMessage<::uif::MouseEvent>(Arena*);
template<> ::uif::PCArc* Arena::CreateMaybeMessage<::uif::PCArc>(Arena*);
template<> ::uif::PCBegin* Arena::CreateMaybeMessage<::uif::PCBegin>(Arena*);
template<> ::uif::PCCubicCurve* Arena::CreateMaybeMessage<::uif::PCCubicCurve>(Arena*);
template<> ::uif::PCEnd* Arena::CreateMaybeMessage<::uif::PCEnd>(Arena*);
template<> ::uif::PCLineTo* Arena::CreateMaybeMessage<::uif::PCLineTo>(Arena*);
template<> ::uif::PCQuadraticCurve* Arena::CreateMaybeMessage<::uif::PCQuadraticCurve>(Arena*);
template<> ::uif::PathCommand* Arena::CreateMaybeMessage<::uif::PathCommand>(Arena*);
template<> ::uif::PathNode* Arena::CreateMaybeMessage<::uif::PathNode>(Arena*);
template<> ::uif::Point* Arena::CreateMaybeMessage<::uif::Point>(Arena*);
template<> ::uif::Rectangle* Arena::CreateMaybeMessage<::uif::Rectangle>(Arena*);
template<> ::uif::RectangleNode* Arena::CreateMaybeMessage<::uif::RectangleNode>(Arena*);
template<> ::uif::SetClearColorReq* Arena::CreateMaybeMessage<::uif::SetClearColorReq>(Arena*);
template<> ::uif::SetClearColorResp* Arena::CreateMaybeMessage<::uif::SetClearColorResp>(Arena*);
template<> ::uif::SolidBrush* Arena::CreateMaybeMessage<::uif::SolidBrush>(Arena*);
template<> ::uif::TextEditSpan* Arena::CreateMaybeMessage<::uif::TextEditSpan>(Arena*);
template<> ::uif::TextHitEvent* Arena::CreateMaybeMessage<::uif::TextHitEvent>(Arena*);
template<> ::uif::TextNode* Arena::CreateMaybeMessage<::uif::TextNode>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace uif {

enum EditCommand_EditKind : int {
  EditCommand_EditKind_APPEND_CHILD = 0,
  EditCommand_EditKind_REPLACE_NODE = 1,
  EditCommand_EditKind_CLEANUP_CLIENT = 2,
  EditCommand_EditKind_DELETE_OBJECT = 3,
  EditCommand_EditKind_EditCommand_EditKind_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EditCommand_EditKind_EditCommand_EditKind_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EditCommand_EditKind_IsValid(int value);
constexpr EditCommand_EditKind EditCommand_EditKind_EditKind_MIN = EditCommand_EditKind_APPEND_CHILD;
constexpr EditCommand_EditKind EditCommand_EditKind_EditKind_MAX = EditCommand_EditKind_DELETE_OBJECT;
constexpr int EditCommand_EditKind_EditKind_ARRAYSIZE = EditCommand_EditKind_EditKind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EditCommand_EditKind_descriptor();
template<typename T>
inline const std::string& EditCommand_EditKind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EditCommand_EditKind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EditCommand_EditKind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EditCommand_EditKind_descriptor(), enum_t_value);
}
inline bool EditCommand_EditKind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EditCommand_EditKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EditCommand_EditKind>(
    EditCommand_EditKind_descriptor(), name, value);
}
enum FontStyle : int {
  FONT_STYLE_NORMAL = 0,
  FONT_STYLE_OBLIQUE = 1,
  FONT_STYLE_ITALIC = 2,
  FontStyle_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FontStyle_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FontStyle_IsValid(int value);
constexpr FontStyle FontStyle_MIN = FONT_STYLE_NORMAL;
constexpr FontStyle FontStyle_MAX = FONT_STYLE_ITALIC;
constexpr int FontStyle_ARRAYSIZE = FontStyle_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FontStyle_descriptor();
template<typename T>
inline const std::string& FontStyle_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FontStyle>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FontStyle_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FontStyle_descriptor(), enum_t_value);
}
inline bool FontStyle_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FontStyle* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FontStyle>(
    FontStyle_descriptor(), name, value);
}
enum FontWeight : int {
  FONT_WEIGHT_UNDEFINED = 0,
  FONT_WEIGHT_THIN = 100,
  FONT_WEIGHT_EXTRA_LIGHT = 200,
  FONT_WEIGHT_LIGHT = 300,
  FONT_WEIGHT_SEMI_LIGHT = 350,
  FONT_WEIGHT_NORMAL = 400,
  FONT_WEIGHT_MEDIUM = 500,
  FONT_WEIGHT_SEMI_BOLD = 600,
  FONT_WEIGHT_BOLD = 700,
  FONT_WEIGHT_EXTRA_BOLD = 800,
  FONT_WEIGHT_BLACK = 900,
  FONT_WEIGHT_EXTRA_BLACK = 950,
  FontWeight_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FontWeight_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FontWeight_IsValid(int value);
constexpr FontWeight FontWeight_MIN = FONT_WEIGHT_UNDEFINED;
constexpr FontWeight FontWeight_MAX = FONT_WEIGHT_EXTRA_BLACK;
constexpr int FontWeight_ARRAYSIZE = FontWeight_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FontWeight_descriptor();
template<typename T>
inline const std::string& FontWeight_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FontWeight>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FontWeight_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FontWeight_descriptor(), enum_t_value);
}
inline bool FontWeight_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FontWeight* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FontWeight>(
    FontWeight_descriptor(), name, value);
}
enum FontStretch : int {
  FONT_STRETCH_UNDEFINED = 0,
  FONT_STRETCH_ULTRA_CONDENSED = 1,
  FONT_STRETCH_EXTRA_CONDENSED = 2,
  FONT_STRETCH_CONDENSED = 3,
  FONT_STRETCH_SEMI_CONDENSED = 4,
  FONT_STRETCH_NORMAL = 5,
  FONT_STRETCH_SEMI_EXPANDED = 6,
  FONT_STRETCH_EXPANDED = 7,
  FONT_STRETCH_EXTRA_EXPANDED = 8,
  FONT_STRETCH_ULTRA_EXPANDED = 9,
  FontStretch_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FontStretch_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FontStretch_IsValid(int value);
constexpr FontStretch FontStretch_MIN = FONT_STRETCH_UNDEFINED;
constexpr FontStretch FontStretch_MAX = FONT_STRETCH_ULTRA_EXPANDED;
constexpr int FontStretch_ARRAYSIZE = FontStretch_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FontStretch_descriptor();
template<typename T>
inline const std::string& FontStretch_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FontStretch>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FontStretch_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FontStretch_descriptor(), enum_t_value);
}
inline bool FontStretch_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FontStretch* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FontStretch>(
    FontStretch_descriptor(), name, value);
}
enum TextAlign : int {
  TEXT_ALIGN_LEADING = 0,
  TEXT_ALIGN_TRAILING = 1,
  TEXT_ALIGN_CENTER = 2,
  TEXT_ALIGN_JUSTIFIED = 3,
  TextAlign_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TextAlign_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TextAlign_IsValid(int value);
constexpr TextAlign TextAlign_MIN = TEXT_ALIGN_LEADING;
constexpr TextAlign TextAlign_MAX = TEXT_ALIGN_JUSTIFIED;
constexpr int TextAlign_ARRAYSIZE = TextAlign_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TextAlign_descriptor();
template<typename T>
inline const std::string& TextAlign_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TextAlign>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TextAlign_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TextAlign_descriptor(), enum_t_value);
}
inline bool TextAlign_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TextAlign* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TextAlign>(
    TextAlign_descriptor(), name, value);
}
enum ParagraphAlign : int {
  PARAGRAPH_ALIGN_NEAR = 0,
  PARAGRAPH_ALIGN_FAR = 1,
  PARAGRAPH_ALIGN_CENTER = 2,
  ParagraphAlign_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ParagraphAlign_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ParagraphAlign_IsValid(int value);
constexpr ParagraphAlign ParagraphAlign_MIN = PARAGRAPH_ALIGN_NEAR;
constexpr ParagraphAlign ParagraphAlign_MAX = PARAGRAPH_ALIGN_CENTER;
constexpr int ParagraphAlign_ARRAYSIZE = ParagraphAlign_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ParagraphAlign_descriptor();
template<typename T>
inline const std::string& ParagraphAlign_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ParagraphAlign>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ParagraphAlign_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ParagraphAlign_descriptor(), enum_t_value);
}
inline bool ParagraphAlign_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ParagraphAlign* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ParagraphAlign>(
    ParagraphAlign_descriptor(), name, value);
}
enum PCBeginKind : int {
  PC_BEGINKIND_FILLED = 0,
  PC_BEGINKIND_HOLLOW = 1,
  PCBeginKind_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PCBeginKind_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PCBeginKind_IsValid(int value);
constexpr PCBeginKind PCBeginKind_MIN = PC_BEGINKIND_FILLED;
constexpr PCBeginKind PCBeginKind_MAX = PC_BEGINKIND_HOLLOW;
constexpr int PCBeginKind_ARRAYSIZE = PCBeginKind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PCBeginKind_descriptor();
template<typename T>
inline const std::string& PCBeginKind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PCBeginKind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PCBeginKind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PCBeginKind_descriptor(), enum_t_value);
}
inline bool PCBeginKind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PCBeginKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PCBeginKind>(
    PCBeginKind_descriptor(), name, value);
}
enum PCEndKind : int {
  PC_ENDKIND_OPEN = 0,
  PC_ENDKIND_CLOSED = 1,
  PCEndKind_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PCEndKind_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PCEndKind_IsValid(int value);
constexpr PCEndKind PCEndKind_MIN = PC_ENDKIND_OPEN;
constexpr PCEndKind PCEndKind_MAX = PC_ENDKIND_CLOSED;
constexpr int PCEndKind_ARRAYSIZE = PCEndKind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PCEndKind_descriptor();
template<typename T>
inline const std::string& PCEndKind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PCEndKind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PCEndKind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PCEndKind_descriptor(), enum_t_value);
}
inline bool PCEndKind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PCEndKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PCEndKind>(
    PCEndKind_descriptor(), name, value);
}
enum MouseButton : int {
  MOUSE_BUTTON_NONE = 0,
  MOUSE_BUTTON_LEFT = 1,
  MOUSE_BUTTON_MIDDLE = 2,
  MOUSE_BUTTON_RIGHT = 3,
  MOUSE_BUTTON_X1 = 4,
  MOUSE_BUTTON_X2 = 5,
  MouseButton_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MouseButton_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MouseButton_IsValid(int value);
constexpr MouseButton MouseButton_MIN = MOUSE_BUTTON_NONE;
constexpr MouseButton MouseButton_MAX = MOUSE_BUTTON_X2;
constexpr int MouseButton_ARRAYSIZE = MouseButton_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MouseButton_descriptor();
template<typename T>
inline const std::string& MouseButton_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MouseButton>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MouseButton_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MouseButton_descriptor(), enum_t_value);
}
inline bool MouseButton_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MouseButton* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MouseButton>(
    MouseButton_descriptor(), name, value);
}
enum MouseState : int {
  MOUSE_STATE_NONE = 0,
  MOUSE_STATE_UP = 1,
  MOUSE_STATE_DOWN = 2,
  MouseState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MouseState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MouseState_IsValid(int value);
constexpr MouseState MouseState_MIN = MOUSE_STATE_NONE;
constexpr MouseState MouseState_MAX = MOUSE_STATE_DOWN;
constexpr int MouseState_ARRAYSIZE = MouseState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MouseState_descriptor();
template<typename T>
inline const std::string& MouseState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MouseState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MouseState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MouseState_descriptor(), enum_t_value);
}
inline bool MouseState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MouseState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MouseState>(
    MouseState_descriptor(), name, value);
}
enum KeyState : int {
  UNSET = 0,
  KEY_DOWN = 1,
  KEY_UP = 2,
  KeyState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  KeyState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool KeyState_IsValid(int value);
constexpr KeyState KeyState_MIN = UNSET;
constexpr KeyState KeyState_MAX = KEY_UP;
constexpr int KeyState_ARRAYSIZE = KeyState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* KeyState_descriptor();
template<typename T>
inline const std::string& KeyState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, KeyState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function KeyState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    KeyState_descriptor(), enum_t_value);
}
inline bool KeyState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, KeyState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<KeyState>(
    KeyState_descriptor(), name, value);
}
// ===================================================================

class Point final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uif.Point) */ {
 public:
  inline Point() : Point(nullptr) {}
  ~Point() override;
  explicit constexpr Point(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Point(const Point& from);
  Point(Point&& from) noexcept
    : Point() {
    *this = ::std::move(from);
  }

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }
  inline Point& operator=(Point&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Point& default_instance() {
    return *internal_default_instance();
  }
  static inline const Point* internal_default_instance() {
    return reinterpret_cast<const Point*>(
               &_Point_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Point& a, Point& b) {
    a.Swap(&b);
  }
  inline void Swap(Point* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Point* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Point* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Point>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Point& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Point& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uif.Point";
  }
  protected:
  explicit Point(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:uif.Point)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float x_;
  float y_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_uif_2eproto;
};
// -------------------------------------------------------------------

class Rectangle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uif.Rectangle) */ {
 public:
  inline Rectangle() : Rectangle(nullptr) {}
  ~Rectangle() override;
  explicit constexpr Rectangle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Rectangle(const Rectangle& from);
  Rectangle(Rectangle&& from) noexcept
    : Rectangle() {
    *this = ::std::move(from);
  }

  inline Rectangle& operator=(const Rectangle& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rectangle& operator=(Rectangle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rectangle& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rectangle* internal_default_instance() {
    return reinterpret_cast<const Rectangle*>(
               &_Rectangle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Rectangle& a, Rectangle& b) {
    a.Swap(&b);
  }
  inline void Swap(Rectangle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rectangle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rectangle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rectangle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Rectangle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Rectangle& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rectangle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uif.Rectangle";
  }
  protected:
  explicit Rectangle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kWidthFieldNumber = 3,
    kHeightFieldNumber = 4,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float width = 3;
  void clear_width();
  float width() const;
  void set_width(float value);
  private:
  float _internal_width() const;
  void _internal_set_width(float value);
  public:

  // float height = 4;
  void clear_height();
  float height() const;
  void set_height(float value);
  private:
  float _internal_height() const;
  void _internal_set_height(float value);
  public:

  // @@protoc_insertion_point(class_scope:uif.Rectangle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float x_;
  float y_;
  float width_;
  float height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_uif_2eproto;
};
// -------------------------------------------------------------------

class SolidBrush final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uif.SolidBrush) */ {
 public:
  inline SolidBrush() : SolidBrush(nullptr) {}
  ~SolidBrush() override;
  explicit constexpr SolidBrush(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SolidBrush(const SolidBrush& from);
  SolidBrush(SolidBrush&& from) noexcept
    : SolidBrush() {
    *this = ::std::move(from);
  }

  inline SolidBrush& operator=(const SolidBrush& from) {
    CopyFrom(from);
    return *this;
  }
  inline SolidBrush& operator=(SolidBrush&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SolidBrush& default_instance() {
    return *internal_default_instance();
  }
  static inline const SolidBrush* internal_default_instance() {
    return reinterpret_cast<const SolidBrush*>(
               &_SolidBrush_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SolidBrush& a, SolidBrush& b) {
    a.Swap(&b);
  }
  inline void Swap(SolidBrush* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SolidBrush* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SolidBrush* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SolidBrush>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SolidBrush& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SolidBrush& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SolidBrush* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uif.SolidBrush";
  }
  protected:
  explicit SolidBrush(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 1,
  };
  // uint32 color = 1;
  void clear_color();
  uint32_t color() const;
  void set_color(uint32_t value);
  private:
  uint32_t _internal_color() const;
  void _internal_set_color(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:uif.SolidBrush)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t color_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_uif_2eproto;
};
// -------------------------------------------------------------------

class GradientStop final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uif.GradientStop) */ {
 public:
  inline GradientStop() : GradientStop(nullptr) {}
  ~GradientStop() override;
  explicit constexpr GradientStop(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GradientStop(const GradientStop& from);
  GradientStop(GradientStop&& from) noexcept
    : GradientStop() {
    *this = ::std::move(from);
  }

  inline GradientStop& operator=(const GradientStop& from) {
    CopyFrom(from);
    return *this;
  }
  inline GradientStop& operator=(GradientStop&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GradientStop& default_instance() {
    return *internal_default_instance();
  }
  static inline const GradientStop* internal_default_instance() {
    return reinterpret_cast<const GradientStop*>(
               &_GradientStop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GradientStop& a, GradientStop& b) {
    a.Swap(&b);
  }
  inline void Swap(GradientStop* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GradientStop* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GradientStop* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GradientStop>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GradientStop& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GradientStop& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GradientStop* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uif.GradientStop";
  }
  protected:
  explicit GradientStop(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 1,
    kPositionFieldNumber = 2,
  };
  // uint32 color = 1;
  void clear_color();
  uint32_t color() const;
  void set_color(uint32_t value);
  private:
  uint32_t _internal_color() const;
  void _internal_set_color(uint32_t value);
  public:

  // float position = 2;
  void clear_position();
  float position() const;
  void set_position(float value);
  private:
  float _internal_position() const;
  void _internal_set_position(float value);
  public:

  // @@protoc_insertion_point(class_scope:uif.GradientStop)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t color_;
  float position_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_uif_2eproto;
};
// -------------------------------------------------------------------

class LinearGradientBrush final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uif.LinearGradientBrush) */ {
 public:
  inline LinearGradientBrush() : LinearGradientBrush(nullptr) {}
  ~LinearGradientBrush() override;
  explicit constexpr LinearGradientBrush(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LinearGradientBrush(const LinearGradientBrush& from);
  LinearGradientBrush(LinearGradientBrush&& from) noexcept
    : LinearGradientBrush() {
    *this = ::std::move(from);
  }

  inline LinearGradientBrush& operator=(const LinearGradientBrush& from) {
    CopyFrom(from);
    return *this;
  }
  inline LinearGradientBrush& operator=(LinearGradientBrush&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LinearGradientBrush& default_instance() {
    return *internal_default_instance();
  }
  static inline const LinearGradientBrush* internal_default_instance() {
    return reinterpret_cast<const LinearGradientBrush*>(
               &_LinearGradientBrush_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LinearGradientBrush& a, LinearGradientBrush& b) {
    a.Swap(&b);
  }
  inline void Swap(LinearGradientBrush* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LinearGradientBrush* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LinearGradientBrush* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LinearGradientBrush>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LinearGradientBrush& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LinearGradientBrush& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LinearGradientBrush* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uif.LinearGradientBrush";
  }
  protected:
  explicit LinearGradientBrush(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStopsFieldNumber = 1,
    kStartFieldNumber = 2,
    kEndFieldNumber = 3,
  };
  // repeated .uif.GradientStop stops = 1;
  int stops_size() const;
  private:
  int _internal_stops_size() const;
  public:
  void clear_stops();
  ::uif::GradientStop* mutable_stops(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::uif::GradientStop >*
      mutable_stops();
  private:
  const ::uif::GradientStop& _internal_stops(int index) const;
  ::uif::GradientStop* _internal_add_stops();
  public:
  const ::uif::GradientStop& stops(int index) const;
  ::uif::GradientStop* add_stops();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::uif::GradientStop >&
      stops() const;

  // .uif.Point start = 2;
  bool has_start() const;
  private:
  bool _internal_has_start() const;
  public:
  void clear_start();
  const ::uif::Point& start() const;
  PROTOBUF_NODISCARD ::uif::Point* release_start();
  ::uif::Point* mutable_start();
  void set_allocated_start(::uif::Point* start);
  private:
  const ::uif::Point& _internal_start() const;
  ::uif::Point* _internal_mutable_start();
  public:
  void unsafe_arena_set_allocated_start(
      ::uif::Point* start);
  ::uif::Point* unsafe_arena_release_start();

  // .uif.Point end = 3;
  bool has_end() const;
  private:
  bool _internal_has_end() const;
  public:
  void clear_end();
  const ::uif::Point& end() const;
  PROTOBUF_NODISCARD ::uif::Point* release_end();
  ::uif::Point* mutable_end();
  void set_allocated_end(::uif::Point* end);
  private:
  const ::uif::Point& _internal_end() const;
  ::uif::Point* _internal_mutable_end();
  public:
  void unsafe_arena_set_allocated_end(
      ::uif::Point* end);
  ::uif::Point* unsafe_arena_release_end();

  // @@protoc_insertion_point(class_scope:uif.LinearGradientBrush)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::uif::GradientStop > stops_;
  ::uif::Point* start_;
  ::uif::Point* end_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_uif_2eproto;
};
// -------------------------------------------------------------------

class Brush final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uif.Brush) */ {
 public:
  inline Brush() : Brush(nullptr) {}
  ~Brush() override;
  explicit constexpr Brush(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Brush(const Brush& from);
  Brush(Brush&& from) noexcept
    : Brush() {
    *this = ::std::move(from);
  }

  inline Brush& operator=(const Brush& from) {
    CopyFrom(from);
    return *this;
  }
  inline Brush& operator=(Brush&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Brush& default_instance() {
    return *internal_default_instance();
  }
  enum KindCase {
    kSolid = 1,
    kLinear = 2,
    KIND_NOT_SET = 0,
  };

  static inline const Brush* internal_default_instance() {
    return reinterpret_cast<const Brush*>(
               &_Brush_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Brush& a, Brush& b) {
    a.Swap(&b);
  }
  inline void Swap(Brush* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Brush* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Brush* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Brush>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Brush& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Brush& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Brush* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uif.Brush";
  }
  protected:
  explicit Brush(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSolidFieldNumber = 1,
    kLinearFieldNumber = 2,
  };
  // .uif.SolidBrush solid = 1;
  bool has_solid() const;
  private:
  bool _internal_has_solid() const;
  public:
  void clear_solid();
  const ::uif::SolidBrush& solid() const;
  PROTOBUF_NODISCARD ::uif::SolidBrush* release_solid();
  ::uif::SolidBrush* mutable_solid();
  void set_allocated_solid(::uif::SolidBrush* solid);
  private:
  const ::uif::SolidBrush& _internal_solid() const;
  ::uif::SolidBrush* _internal_mutable_solid();
  public:
  void unsafe_arena_set_allocated_solid(
      ::uif::SolidBrush* solid);
  ::uif::SolidBrush* unsafe_arena_release_solid();

  // .uif.LinearGradientBrush linear = 2;
  bool has_linear() const;
  private:
  bool _internal_has_linear() const;
  public:
  void clear_linear();
  const ::uif::LinearGradientBrush& linear() const;
  PROTOBUF_NODISCARD ::uif::LinearGradientBrush* release_linear();
  ::uif::LinearGradientBrush* mutable_linear();
  void set_allocated_linear(::uif::LinearGradientBrush* linear);
  private:
  const ::uif::LinearGradientBrush& _internal_linear() const;
  ::uif::LinearGradientBrush* _internal_mutable_linear();
  public:
  void unsafe_arena_set_allocated_linear(
      ::uif::LinearGradientBrush* linear);
  ::uif::LinearGradientBrush* unsafe_arena_release_linear();

  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:uif.Brush)
 private:
  class _Internal;
  void set_has_solid();
  void set_has_linear();

  inline bool has_kind() const;
  inline void clear_has_kind();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union KindUnion {
    constexpr KindUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::uif::SolidBrush* solid_;
    ::uif::LinearGradientBrush* linear_;
  } kind_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_uif_2eproto;
};
// -------------------------------------------------------------------

class RectangleNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uif.RectangleNode) */ {
 public:
  inline RectangleNode() : RectangleNode(nullptr) {}
  ~RectangleNode() override;
  explicit constexpr RectangleNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RectangleNode(const RectangleNode& from);
  RectangleNode(RectangleNode&& from) noexcept
    : RectangleNode() {
    *this = ::std::move(from);
  }

  inline RectangleNode& operator=(const RectangleNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline RectangleNode& operator=(RectangleNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RectangleNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const RectangleNode* internal_default_instance() {
    return reinterpret_cast<const RectangleNode*>(
               &_RectangleNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RectangleNode& a, RectangleNode& b) {
    a.Swap(&b);
  }
  inline void Swap(RectangleNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RectangleNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RectangleNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RectangleNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RectangleNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RectangleNode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RectangleNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uif.RectangleNode";
  }
  protected:
  explicit RectangleNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRectFieldNumber = 1,
    kStrokeFieldNumber = 2,
    kFilledFieldNumber = 3,
    kRoundedRadiusXFieldNumber = 4,
    kRoundedRadiusYFieldNumber = 5,
    kStrokeWidthFieldNumber = 6,
  };
  // .uif.Rectangle rect = 1;
  bool has_rect() const;
  private:
  bool _internal_has_rect() const;
  public:
  void clear_rect();
  const ::uif::Rectangle& rect() const;
  PROTOBUF_NODISCARD ::uif::Rectangle* release_rect();
  ::uif::Rectangle* mutable_rect();
  void set_allocated_rect(::uif::Rectangle* rect);
  private:
  const ::uif::Rectangle& _internal_rect() const;
  ::uif::Rectangle* _internal_mutable_rect();
  public:
  void unsafe_arena_set_allocated_rect(
      ::uif::Rectangle* rect);
  ::uif::Rectangle* unsafe_arena_release_rect();

  // .uif.Brush stroke = 2;
  bool has_stroke() const;
  private:
  bool _internal_has_stroke() const;
  public:
  void clear_stroke();
  const ::uif::Brush& stroke() const;
  PROTOBUF_NODISCARD ::uif::Brush* release_stroke();
  ::uif::Brush* mutable_stroke();
  void set_allocated_stroke(::uif::Brush* stroke);
  private:
  const ::uif::Brush& _internal_stroke() const;
  ::uif::Brush* _internal_mutable_stroke();
  public:
  void unsafe_arena_set_allocated_stroke(
      ::uif::Brush* stroke);
  ::uif::Brush* unsafe_arena_release_stroke();

  // bool filled = 3;
  void clear_filled();
  bool filled() const;
  void set_filled(bool value);
  private:
  bool _internal_filled() const;
  void _internal_set_filled(bool value);
  public:

  // float rounded_radius_x = 4;
  void clear_rounded_radius_x();
  float rounded_radius_x() const;
  void set_rounded_radius_x(float value);
  private:
  float _internal_rounded_radius_x() const;
  void _internal_set_rounded_radius_x(float value);
  public:

  // float rounded_radius_y = 5;
  void clear_rounded_radius_y();
  float rounded_radius_y() const;
  void set_rounded_radius_y(float value);
  private:
  float _internal_rounded_radius_y() const;
  void _internal_set_rounded_radius_y(float value);
  public:

  // float stroke_width = 6;
  void clear_stroke_width();
  float stroke_width() const;
  void set_stroke_width(float value);
  private:
  float _internal_stroke_width() const;
  void _internal_set_stroke_width(float value);
  public:

  // @@protoc_insertion_point(class_scope:uif.RectangleNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::uif::Rectangle* rect_;
  ::uif::Brush* stroke_;
  bool filled_;
  float rounded_radius_x_;
  float rounded_radius_y_;
  float stroke_width_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_uif_2eproto;
};
// -------------------------------------------------------------------

class TextEditSpan final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uif.TextEditSpan) */ {
 public:
  inline TextEditSpan() : TextEditSpan(nullptr) {}
  ~TextEditSpan() override;
  explicit constexpr TextEditSpan(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TextEditSpan(const TextEditSpan& from);
  TextEditSpan(TextEditSpan&& from) noexcept
    : TextEditSpan() {
    *this = ::std::move(from);
  }

  inline TextEditSpan& operator=(const TextEditSpan& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextEditSpan& operator=(TextEditSpan&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TextEditSpan& default_instance() {
    return *internal_default_instance();
  }
  enum EditCase {
    kFontName = 4,
    kFontWeight = 5,
    kFontStyle = 6,
    kFontStretch = 7,
    kFontSize = 8,
    kBrush = 9,
    kUnderline = 10,
    EDIT_NOT_SET = 0,
  };

  static inline const TextEditSpan* internal_default_instance() {
    return reinterpret_cast<const TextEditSpan*>(
               &_TextEditSpan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TextEditSpan& a, TextEditSpan& b) {
    a.Swap(&b);
  }
  inline void Swap(TextEditSpan* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextEditSpan* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TextEditSpan* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TextEditSpan>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TextEditSpan& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TextEditSpan& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextEditSpan* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uif.TextEditSpan";
  }
  protected:
  explicit TextEditSpan(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOffsetFieldNumber = 1,
    kLengthFieldNumber = 2,
    kFontNameFieldNumber = 4,
    kFontWeightFieldNumber = 5,
    kFontStyleFieldNumber = 6,
    kFontStretchFieldNumber = 7,
    kFontSizeFieldNumber = 8,
    kBrushFieldNumber = 9,
    kUnderlineFieldNumber = 10,
  };
  // int32 offset = 1;
  void clear_offset();
  int32_t offset() const;
  void set_offset(int32_t value);
  private:
  int32_t _internal_offset() const;
  void _internal_set_offset(int32_t value);
  public:

  // int32 length = 2;
  void clear_length();
  int32_t length() const;
  void set_length(int32_t value);
  private:
  int32_t _internal_length() const;
  void _internal_set_length(int32_t value);
  public:

  // string font_name = 4;
  bool has_font_name() const;
  private:
  bool _internal_has_font_name() const;
  public:
  void clear_font_name();
  const std::string& font_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_font_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_font_name();
  PROTOBUF_NODISCARD std::string* release_font_name();
  void set_allocated_font_name(std::string* font_name);
  private:
  const std::string& _internal_font_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_font_name(const std::string& value);
  std::string* _internal_mutable_font_name();
  public:

  // .uif.FontWeight font_weight = 5;
  bool has_font_weight() const;
  private:
  bool _internal_has_font_weight() const;
  public:
  void clear_font_weight();
  ::uif::FontWeight font_weight() const;
  void set_font_weight(::uif::FontWeight value);
  private:
  ::uif::FontWeight _internal_font_weight() const;
  void _internal_set_font_weight(::uif::FontWeight value);
  public:

  // .uif.FontStyle font_style = 6;
  bool has_font_style() const;
  private:
  bool _internal_has_font_style() const;
  public:
  void clear_font_style();
  ::uif::FontStyle font_style() const;
  void set_font_style(::uif::FontStyle value);
  private:
  ::uif::FontStyle _internal_font_style() const;
  void _internal_set_font_style(::uif::FontStyle value);
  public:

  // .uif.FontStretch font_stretch = 7;
  bool has_font_stretch() const;
  private:
  bool _internal_has_font_stretch() const;
  public:
  void clear_font_stretch();
  ::uif::FontStretch font_stretch() const;
  void set_font_stretch(::uif::FontStretch value);
  private:
  ::uif::FontStretch _internal_font_stretch() const;
  void _internal_set_font_stretch(::uif::FontStretch value);
  public:

  // float font_size = 8;
  bool has_font_size() const;
  private:
  bool _internal_has_font_size() const;
  public:
  void clear_font_size();
  float font_size() const;
  void set_font_size(float value);
  private:
  float _internal_font_size() const;
  void _internal_set_font_size(float value);
  public:

  // .uif.Brush brush = 9;
  bool has_brush() const;
  private:
  bool _internal_has_brush() const;
  public:
  void clear_brush();
  const ::uif::Brush& brush() const;
  PROTOBUF_NODISCARD ::uif::Brush* release_brush();
  ::uif::Brush* mutable_brush();
  void set_allocated_brush(::uif::Brush* brush);
  private:
  const ::uif::Brush& _internal_brush() const;
  ::uif::Brush* _internal_mutable_brush();
  public:
  void unsafe_arena_set_allocated_brush(
      ::uif::Brush* brush);
  ::uif::Brush* unsafe_arena_release_brush();

  // bool underline = 10;
  bool has_underline() const;
  private:
  bool _internal_has_underline() const;
  public:
  void clear_underline();
  bool underline() const;
  void set_underline(bool value);
  private:
  bool _internal_underline() const;
  void _internal_set_underline(bool value);
  public:

  void clear_edit();
  EditCase edit_case() const;
  // @@protoc_insertion_point(class_scope:uif.TextEditSpan)
 private:
  class _Internal;
  void set_has_font_name();
  void set_has_font_weight();
  void set_has_font_style();
  void set_has_font_stretch();
  void set_has_font_size();
  void set_has_brush();
  void set_has_underline();

  inline bool has_edit() const;
  inline void clear_has_edit();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t offset_;
  int32_t length_;
  union EditUnion {
    constexpr EditUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr font_name_;
    int font_weight_;
    int font_style_;
    int font_stretch_;
    float font_size_;
    ::uif::Brush* brush_;
    bool underline_;
  } edit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_uif_2eproto;
};
// -------------------------------------------------------------------

class TextNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uif.TextNode) */ {
 public:
  inline TextNode() : TextNode(nullptr) {}
  ~TextNode() override;
  explicit constexpr TextNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TextNode(const TextNode& from);
  TextNode(TextNode&& from) noexcept
    : TextNode() {
    *this = ::std::move(from);
  }

  inline TextNode& operator=(const TextNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextNode& operator=(TextNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TextNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const TextNode* internal_default_instance() {
    return reinterpret_cast<const TextNode*>(
               &_TextNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TextNode& a, TextNode& b) {
    a.Swap(&b);
  }
  inline void Swap(TextNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TextNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TextNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TextNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TextNode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uif.TextNode";
  }
  protected:
  explicit TextNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEditSpansFieldNumber = 11,
    kTextFieldNumber = 3,
    kFontNameFieldNumber = 4,
    kBoundsFieldNumber = 1,
    kStrokeFieldNumber = 2,
    kFontWeightFieldNumber = 5,
    kFontStyleFieldNumber = 6,
    kFontStretchFieldNumber = 7,
    kFontSizeFieldNumber = 8,
    kTextAlignFieldNumber = 9,
    kParagraphAlignFieldNumber = 10,
  };
  // repeated .uif.TextEditSpan edit_spans = 11;
  int edit_spans_size() const;
  private:
  int _internal_edit_spans_size() const;
  public:
  void clear_edit_spans();
  ::uif::TextEditSpan* mutable_edit_spans(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::uif::TextEditSpan >*
      mutable_edit_spans();
  private:
  const ::uif::TextEditSpan& _internal_edit_spans(int index) const;
  ::uif::TextEditSpan* _internal_add_edit_spans();
  public:
  const ::uif::TextEditSpan& edit_spans(int index) const;
  ::uif::TextEditSpan* add_edit_spans();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::uif::TextEditSpan >&
      edit_spans() const;

  // string text = 3;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // string font_name = 4;
  void clear_font_name();
  const std::string& font_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_font_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_font_name();
  PROTOBUF_NODISCARD std::string* release_font_name();
  void set_allocated_font_name(std::string* font_name);
  private:
  const std::string& _internal_font_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_font_name(const std::string& value);
  std::string* _internal_mutable_font_name();
  public:

  // .uif.Rectangle bounds = 1;
  bool has_bounds() const;
  private:
  bool _internal_has_bounds() const;
  public:
  void clear_bounds();
  const ::uif::Rectangle& bounds() const;
  PROTOBUF_NODISCARD ::uif::Rectangle* release_bounds();
  ::uif::Rectangle* mutable_bounds();
  void set_allocated_bounds(::uif::Rectangle* bounds);
  private:
  const ::uif::Rectangle& _internal_bounds() const;
  ::uif::Rectangle* _internal_mutable_bounds();
  public:
  void unsafe_arena_set_allocated_bounds(
      ::uif::Rectangle* bounds);
  ::uif::Rectangle* unsafe_arena_release_bounds();

  // .uif.Brush stroke = 2;
  bool has_stroke() const;
  private:
  bool _internal_has_stroke() const;
  public:
  void clear_stroke();
  const ::uif::Brush& stroke() const;
  PROTOBUF_NODISCARD ::uif::Brush* release_stroke();
  ::uif::Brush* mutable_stroke();
  void set_allocated_stroke(::uif::Brush* stroke);
  private:
  const ::uif::Brush& _internal_stroke() const;
  ::uif::Brush* _internal_mutable_stroke();
  public:
  void unsafe_arena_set_allocated_stroke(
      ::uif::Brush* stroke);
  ::uif::Brush* unsafe_arena_release_stroke();

  // .uif.FontWeight font_weight = 5;
  void clear_font_weight();
  ::uif::FontWeight font_weight() const;
  void set_font_weight(::uif::FontWeight value);
  private:
  ::uif::FontWeight _internal_font_weight() const;
  void _internal_set_font_weight(::uif::FontWeight value);
  public:

  // .uif.FontStyle font_style = 6;
  void clear_font_style();
  ::uif::FontStyle font_style() const;
  void set_font_style(::uif::FontStyle value);
  private:
  ::uif::FontStyle _internal_font_style() const;
  void _internal_set_font_style(::uif::FontStyle value);
  public:

  // .uif.FontStretch font_stretch = 7;
  void clear_font_stretch();
  ::uif::FontStretch font_stretch() const;
  void set_font_stretch(::uif::FontStretch value);
  private:
  ::uif::FontStretch _internal_font_stretch() const;
  void _internal_set_font_stretch(::uif::FontStretch value);
  public:

  // float font_size = 8;
  void clear_font_size();
  float font_size() const;
  void set_font_size(float value);
  private:
  float _internal_font_size() const;
  void _internal_set_font_size(float value);
  public:

  // .uif.TextAlign text_align = 9;
  void clear_text_align();
  ::uif::TextAlign text_align() const;
  void set_text_align(::uif::TextAlign value);
  private:
  ::uif::TextAlign _internal_text_align() const;
  void _internal_set_text_align(::uif::TextAlign value);
  public:

  // .uif.ParagraphAlign paragraph_align = 10;
  void clear_paragraph_align();
  ::uif::ParagraphAlign paragraph_align() const;
  void set_paragraph_align(::uif::ParagraphAlign value);
  private:
  ::uif::ParagraphAlign _internal_paragraph_align() const;
  void _internal_set_paragraph_align(::uif::ParagraphAlign value);
  public:

  // @@protoc_insertion_point(class_scope:uif.TextNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::uif::TextEditSpan > edit_spans_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr font_name_;
  ::uif::Rectangle* bounds_;
  ::uif::Brush* stroke_;
  int font_weight_;
  int font_style_;
  int font_stretch_;
  float font_size_;
  int text_align_;
  int paragraph_align_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_uif_2eproto;
};
// -------------------------------------------------------------------

class PCBegin final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uif.PCBegin) */ {
 public:
  inline PCBegin() : PCBegin(nullptr) {}
  ~PCBegin() override;
  explicit constexpr PCBegin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PCBegin(const PCBegin& from);
  PCBegin(PCBegin&& from) noexcept
    : PCBegin() {
    *this = ::std::move(from);
  }

  inline PCBegin& operator=(const PCBegin& from) {
    CopyFrom(from);
    return *this;
  }
  inline PCBegin& operator=(PCBegin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PCBegin& default_instance() {
    return *internal_default_instance();
  }
  static inline const PCBegin* internal_default_instance() {
    return reinterpret_cast<const PCBegin*>(
               &_PCBegin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PCBegin& a, PCBegin& b) {
    a.Swap(&b);
  }
  inline void Swap(PCBegin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PCBegin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PCBegin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PCBegin>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PCBegin& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PCBegin& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PCBegin* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uif.PCBegin";
  }
  protected:
  explicit PCBegin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPtFieldNumber = 2,
    kKindFieldNumber = 1,
  };
  // .uif.Point pt = 2;
  bool has_pt() const;
  private:
  bool _internal_has_pt() const;
  public:
  void clear_pt();
  const ::uif::Point& pt() const;
  PROTOBUF_NODISCARD ::uif::Point* release_pt();
  ::uif::Point* mutable_pt();
  void set_allocated_pt(::uif::Point* pt);
  private:
  const ::uif::Point& _internal_pt() const;
  ::uif::Point* _internal_mutable_pt();
  public:
  void unsafe_arena_set_allocated_pt(
      ::uif::Point* pt);
  ::uif::Point* unsafe_arena_release_pt();

  // .uif.PCBeginKind kind = 1;
  void clear_kind();
  ::uif::PCBeginKind kind() const;
  void set_kind(::uif::PCBeginKind value);
  private:
  ::uif::PCBeginKind _internal_kind() const;
  void _internal_set_kind(::uif::PCBeginKind value);
  public:

  // @@protoc_insertion_point(class_scope:uif.PCBegin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::uif::Point* pt_;
  int kind_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_uif_2eproto;
};
// -------------------------------------------------------------------

class PCEnd final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uif.PCEnd) */ {
 public:
  inline PCEnd() : PCEnd(nullptr) {}
  ~PCEnd() override;
  explicit constexpr PCEnd(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PCEnd(const PCEnd& from);
  PCEnd(PCEnd&& from) noexcept
    : PCEnd() {
    *this = ::std::move(from);
  }

  inline PCEnd& operator=(const PCEnd& from) {
    CopyFrom(from);
    return *this;
  }
  inline PCEnd& operator=(PCEnd&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PCEnd& default_instance() {
    return *internal_default_instance();
  }
  static inline const PCEnd* internal_default_instance() {
    return reinterpret_cast<const PCEnd*>(
               &_PCEnd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(PCEnd& a, PCEnd& b) {
    a.Swap(&b);
  }
  inline void Swap(PCEnd* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PCEnd* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PCEnd* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PCEnd>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PCEnd& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PCEnd& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PCEnd* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uif.PCEnd";
  }
  protected:
  explicit PCEnd(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKindFieldNumber = 1,
  };
  // .uif.PCEndKind kind = 1;
  void clear_kind();
  ::uif::PCEndKind kind() const;
  void set_kind(::uif::PCEndKind value);
  private:
  ::uif::PCEndKind _internal_kind() const;
  void _internal_set_kind(::uif::PCEndKind value);
  public:

  // @@protoc_insertion_point(class_scope:uif.PCEnd)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int kind_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_uif_2eproto;
};
// -------------------------------------------------------------------

class PCLineTo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uif.PCLineTo) */ {
 public:
  inline PCLineTo() : PCLineTo(nullptr) {}
  ~PCLineTo() override;
  explicit constexpr PCLineTo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PCLineTo(const PCLineTo& from);
  PCLineTo(PCLineTo&& from) noexcept
    : PCLineTo() {
    *this = ::std::move(from);
  }

  inline PCLineTo& operator=(const PCLineTo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PCLineTo& operator=(PCLineTo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PCLineTo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PCLineTo* internal_default_instance() {
    return reinterpret_cast<const PCLineTo*>(
               &_PCLineTo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(PCLineTo& a, PCLineTo& b) {
    a.Swap(&b);
  }
  inline void Swap(PCLineTo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PCLineTo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PCLineTo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PCLineTo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PCLineTo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PCLineTo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PCLineTo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uif.PCLineTo";
  }
  protected:
  explicit PCLineTo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPtFieldNumber = 1,
  };
  // .uif.Point pt = 1;
  bool has_pt() const;
  private:
  bool _internal_has_pt() const;
  public:
  void clear_pt();
  const ::uif::Point& pt() const;
  PROTOBUF_NODISCARD ::uif::Point* release_pt();
  ::uif::Point* mutable_pt();
  void set_allocated_pt(::uif::Point* pt);
  private:
  const ::uif::Point& _internal_pt() const;
  ::uif::Point* _internal_mutable_pt();
  public:
  void unsafe_arena_set_allocated_pt(
      ::uif::Point* pt);
  ::uif::Point* unsafe_arena_release_pt();

  // @@protoc_insertion_point(class_scope:uif.PCLineTo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::uif::Point* pt_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_uif_2eproto;
};
// -------------------------------------------------------------------

class PCCubicCurve final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uif.PCCubicCurve) */ {
 public:
  inline PCCubicCurve() : PCCubicCurve(nullptr) {}
  ~PCCubicCurve() override;
  explicit constexpr PCCubicCurve(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PCCubicCurve(const PCCubicCurve& from);
  PCCubicCurve(PCCubicCurve&& from) noexcept
    : PCCubicCurve() {
    *this = ::std::move(from);
  }

  inline PCCubicCurve& operator=(const PCCubicCurve& from) {
    CopyFrom(from);
    return *this;
  }
  inline PCCubicCurve& operator=(PCCubicCurve&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PCCubicCurve& default_instance() {
    return *internal_default_instance();
  }
  static inline const PCCubicCurve* internal_default_instance() {
    return reinterpret_cast<const PCCubicCurve*>(
               &_PCCubicCurve_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(PCCubicCurve& a, PCCubicCurve& b) {
    a.Swap(&b);
  }
  inline void Swap(PCCubicCurve* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PCCubicCurve* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PCCubicCurve* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PCCubicCurve>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PCCubicCurve& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PCCubicCurve& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PCCubicCurve* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uif.PCCubicCurve";
  }
  protected:
  explicit PCCubicCurve(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControl1FieldNumber = 1,
    kControl2FieldNumber = 2,
    kEndFieldNumber = 3,
  };
  // .uif.Point control1 = 1;
  bool has_control1() const;
  private:
  bool _internal_has_control1() const;
  public:
  void clear_control1();
  const ::uif::Point& control1() const;
  PROTOBUF_NODISCARD ::uif::Point* release_control1();
  ::uif::Point* mutable_control1();
  void set_allocated_control1(::uif::Point* control1);
  private:
  const ::uif::Point& _internal_control1() const;
  ::uif::Point* _internal_mutable_control1();
  public:
  void unsafe_arena_set_allocated_control1(
      ::uif::Point* control1);
  ::uif::Point* unsafe_arena_release_control1();

  // .uif.Point control2 = 2;
  bool has_control2() const;
  private:
  bool _internal_has_control2() const;
  public:
  void clear_control2();
  const ::uif::Point& control2() const;
  PROTOBUF_NODISCARD ::uif::Point* release_control2();
  ::uif::Point* mutable_control2();
  void set_allocated_control2(::uif::Point* control2);
  private:
  const ::uif::Point& _internal_control2() const;
  ::uif::Point* _internal_mutable_control2();
  public:
  void unsafe_arena_set_allocated_control2(
      ::uif::Point* control2);
  ::uif::Point* unsafe_arena_release_control2();

  // .uif.Point end = 3;
  bool has_end() const;
  private:
  bool _internal_has_end() const;
  public:
  void clear_end();
  const ::uif::Point& end() const;
  PROTOBUF_NODISCARD ::uif::Point* release_end();
  ::uif::Point* mutable_end();
  void set_allocated_end(::uif::Point* end);
  private:
  const ::uif::Point& _internal_end() const;
  ::uif::Point* _internal_mutable_end();
  public:
  void unsafe_arena_set_allocated_end(
      ::uif::Point* end);
  ::uif::Point* unsafe_arena_release_end();

  // @@protoc_insertion_point(class_scope:uif.PCCubicCurve)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::uif::Point* control1_;
  ::uif::Point* control2_;
  ::uif::Point* end_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_uif_2eproto;
};
// -------------------------------------------------------------------

class PCQuadraticCurve final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uif.PCQuadraticCurve) */ {
 public:
  inline PCQuadraticCurve() : PCQuadraticCurve(nullptr) {}
  ~PCQuadraticCurve() override;
  explicit constexpr PCQuadraticCurve(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PCQuadraticCurve(const PCQuadraticCurve& from);
  PCQuadraticCurve(PCQuadraticCurve&& from) noexcept
    : PCQuadraticCurve() {
    *this = ::std::move(from);
  }

  inline PCQuadraticCurve& operator=(const PCQuadraticCurve& from) {
    CopyFrom(from);
    return *this;
  }
  inline PCQuadraticCurve& operator=(PCQuadraticCurve&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PCQuadraticCurve& default_instance() {
    return *internal_default_instance();
  }
  static inline const PCQuadraticCurve* internal_default_instance() {
    return reinterpret_cast<const PCQuadraticCurve*>(
               &_PCQuadraticCurve_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(PCQuadraticCurve& a, PCQuadraticCurve& b) {
    a.Swap(&b);
  }
  inline void Swap(PCQuadraticCurve* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PCQuadraticCurve* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PCQuadraticCurve* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PCQuadraticCurve>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PCQuadraticCurve& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PCQuadraticCurve& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PCQuadraticCurve* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uif.PCQuadraticCurve";
  }
  protected:
  explicit PCQuadraticCurve(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControl1FieldNumber = 1,
    kEndFieldNumber = 2,
  };
  // .uif.Point control1 = 1;
  bool has_control1() const;
  private:
  bool _internal_has_control1() const;
  public:
  void clear_control1();
  const ::uif::Point& control1() const;
  PROTOBUF_NODISCARD ::uif::Point* release_control1();
  ::uif::Point* mutable_control1();
  void set_allocated_control1(::uif::Point* control1);
  private:
  const ::uif::Point& _internal_control1() const;
  ::uif::Point* _internal_mutable_control1();
  public:
  void unsafe_arena_set_allocated_control1(
      ::uif::Point* control1);
  ::uif::Point* unsafe_arena_release_control1();

  // .uif.Point end = 2;
  bool has_end() const;
  private:
  bool _internal_has_end() const;
  public:
  void clear_end();
  const ::uif::Point& end() const;
  PROTOBUF_NODISCARD ::uif::Point* release_end();
  ::uif::Point* mutable_end();
  void set_allocated_end(::uif::Point* end);
  private:
  const ::uif::Point& _internal_end() const;
  ::uif::Point* _internal_mutable_end();
  public:
  void unsafe_arena_set_allocated_end(
      ::uif::Point* end);
  ::uif::Point* unsafe_arena_release_end();

  // @@protoc_insertion_point(class_scope:uif.PCQuadraticCurve)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::uif::Point* control1_;
  ::uif::Point* end_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_uif_2eproto;
};
// -------------------------------------------------------------------

class PCArc final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uif.PCArc) */ {
 public:
  inline PCArc() : PCArc(nullptr) {}
  ~PCArc() override;
  explicit constexpr PCArc(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PCArc(const PCArc& from);
  PCArc(PCArc&& from) noexcept
    : PCArc() {
    *this = ::std::move(from);
  }

  inline PCArc& operator=(const PCArc& from) {
    CopyFrom(from);
    return *this;
  }
  inline PCArc& operator=(PCArc&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PCArc& default_instance() {
    return *internal_default_instance();
  }
  static inline const PCArc* internal_default_instance() {
    return reinterpret_cast<const PCArc*>(
               &_PCArc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(PCArc& a, PCArc& b) {
    a.Swap(&b);
  }
  inline void Swap(PCArc* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PCArc* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PCArc* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PCArc>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PCArc& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PCArc& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PCArc* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uif.PCArc";
  }
  protected:
  explicit PCArc(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEndFieldNumber = 6,
    kXRadiusFieldNumber = 1,
    kYRadiusFieldNumber = 2,
    kXAxisRotationFieldNumber = 3,
    kLargeArcFlagFieldNumber = 4,
    kSweepFlagFieldNumber = 5,
  };
  // .uif.Point end = 6;
  bool has_end() const;
  private:
  bool _internal_has_end() const;
  public:
  void clear_end();
  const ::uif::Point& end() const;
  PROTOBUF_NODISCARD ::uif::Point* release_end();
  ::uif::Point* mutable_end();
  void set_allocated_end(::uif::Point* end);
  private:
  const ::uif::Point& _internal_end() const;
  ::uif::Point* _internal_mutable_end();
  public:
  void unsafe_arena_set_allocated_end(
      ::uif::Point* end);
  ::uif::Point* unsafe_arena_release_end();

  // float x_radius = 1;
  void clear_x_radius();
  float x_radius() const;
  void set_x_radius(float value);
  private:
  float _internal_x_radius() const;
  void _internal_set_x_radius(float value);
  public:

  // float y_radius = 2;
  void clear_y_radius();
  float y_radius() const;
  void set_y_radius(float value);
  private:
  float _internal_y_radius() const;
  void _internal_set_y_radius(float value);
  public:

  // float x_axis_rotation = 3;
  void clear_x_axis_rotation();
  float x_axis_rotation() const;
  void set_x_axis_rotation(float value);
  private:
  float _internal_x_axis_rotation() const;
  void _internal_set_x_axis_rotation(float value);
  public:

  // bool large_arc_flag = 4;
  void clear_large_arc_flag();
  bool large_arc_flag() const;
  void set_large_arc_flag(bool value);
  private:
  bool _internal_large_arc_flag() const;
  void _internal_set_large_arc_flag(bool value);
  public:

  // bool sweep_flag = 5;
  void clear_sweep_flag();
  bool sweep_flag() const;
  void set_sweep_flag(bool value);
  private:
  bool _internal_sweep_flag() const;
  void _internal_set_sweep_flag(bool value);
  public:

  // @@protoc_insertion_point(class_scope:uif.PCArc)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::uif::Point* end_;
  float x_radius_;
  float y_radius_;
  float x_axis_rotation_;
  bool large_arc_flag_;
  bool sweep_flag_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_uif_2eproto;
};
// -------------------------------------------------------------------

class PathCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uif.PathCommand) */ {
 public:
  inline PathCommand() : PathCommand(nullptr) {}
  ~PathCommand() override;
  explicit constexpr PathCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PathCommand(const PathCommand& from);
  PathCommand(PathCommand&& from) noexcept
    : PathCommand() {
    *this = ::std::move(from);
  }

  inline PathCommand& operator=(const PathCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline PathCommand& operator=(PathCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PathCommand& default_instance() {
    return *internal_default_instance();
  }
  enum CmdCase {
    kBegin = 10,
    kEnd = 20,
    kLineTo = 11,
    kCubicTo = 12,
    kQuadTo = 13,
    kArcTo = 14,
    CMD_NOT_SET = 0,
  };

  static inline const PathCommand* internal_default_instance() {
    return reinterpret_cast<const PathCommand*>(
               &_PathCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(PathCommand& a, PathCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(PathCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PathCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PathCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PathCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PathCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PathCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PathCommand* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uif.PathCommand";
  }
  protected:
  explicit PathCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBeginFieldNumber = 10,
    kEndFieldNumber = 20,
    kLineToFieldNumber = 11,
    kCubicToFieldNumber = 12,
    kQuadToFieldNumber = 13,
    kArcToFieldNumber = 14,
  };
  // .uif.PCBegin begin = 10;
  bool has_begin() const;
  private:
  bool _internal_has_begin() const;
  public:
  void clear_begin();
  const ::uif::PCBegin& begin() const;
  PROTOBUF_NODISCARD ::uif::PCBegin* release_begin();
  ::uif::PCBegin* mutable_begin();
  void set_allocated_begin(::uif::PCBegin* begin);
  private:
  const ::uif::PCBegin& _internal_begin() const;
  ::uif::PCBegin* _internal_mutable_begin();
  public:
  void unsafe_arena_set_allocated_begin(
      ::uif::PCBegin* begin);
  ::uif::PCBegin* unsafe_arena_release_begin();

  // .uif.PCEnd end = 20;
  bool has_end() const;
  private:
  bool _internal_has_end() const;
  public:
  void clear_end();
  const ::uif::PCEnd& end() const;
  PROTOBUF_NODISCARD ::uif::PCEnd* release_end();
  ::uif::PCEnd* mutable_end();
  void set_allocated_end(::uif::PCEnd* end);
  private:
  const ::uif::PCEnd& _internal_end() const;
  ::uif::PCEnd* _internal_mutable_end();
  public:
  void unsafe_arena_set_allocated_end(
      ::uif::PCEnd* end);
  ::uif::PCEnd* unsafe_arena_release_end();

  // .uif.PCLineTo line_to = 11;
  bool has_line_to() const;
  private:
  bool _internal_has_line_to() const;
  public:
  void clear_line_to();
  const ::uif::PCLineTo& line_to() const;
  PROTOBUF_NODISCARD ::uif::PCLineTo* release_line_to();
  ::uif::PCLineTo* mutable_line_to();
  void set_allocated_line_to(::uif::PCLineTo* line_to);
  private:
  const ::uif::PCLineTo& _internal_line_to() const;
  ::uif::PCLineTo* _internal_mutable_line_to();
  public:
  void unsafe_arena_set_allocated_line_to(
      ::uif::PCLineTo* line_to);
  ::uif::PCLineTo* unsafe_arena_release_line_to();

  // .uif.PCCubicCurve cubic_to = 12;
  bool has_cubic_to() const;
  private:
  bool _internal_has_cubic_to() const;
  public:
  void clear_cubic_to();
  const ::uif::PCCubicCurve& cubic_to() const;
  PROTOBUF_NODISCARD ::uif::PCCubicCurve* release_cubic_to();
  ::uif::PCCubicCurve* mutable_cubic_to();
  void set_allocated_cubic_to(::uif::PCCubicCurve* cubic_to);
  private:
  const ::uif::PCCubicCurve& _internal_cubic_to() const;
  ::uif::PCCubicCurve* _internal_mutable_cubic_to();
  public:
  void unsafe_arena_set_allocated_cubic_to(
      ::uif::PCCubicCurve* cubic_to);
  ::uif::PCCubicCurve* unsafe_arena_release_cubic_to();

  // .uif.PCQuadraticCurve quad_to = 13;
  bool has_quad_to() const;
  private:
  bool _internal_has_quad_to() const;
  public:
  void clear_quad_to();
  const ::uif::PCQuadraticCurve& quad_to() const;
  PROTOBUF_NODISCARD ::uif::PCQuadraticCurve* release_quad_to();
  ::uif::PCQuadraticCurve* mutable_quad_to();
  void set_allocated_quad_to(::uif::PCQuadraticCurve* quad_to);
  private:
  const ::uif::PCQuadraticCurve& _internal_quad_to() const;
  ::uif::PCQuadraticCurve* _internal_mutable_quad_to();
  public:
  void unsafe_arena_set_allocated_quad_to(
      ::uif::PCQuadraticCurve* quad_to);
  ::uif::PCQuadraticCurve* unsafe_arena_release_quad_to();

  // .uif.PCArc arc_to = 14;
  bool has_arc_to() const;
  private:
  bool _internal_has_arc_to() const;
  public:
  void clear_arc_to();
  const ::uif::PCArc& arc_to() const;
  PROTOBUF_NODISCARD ::uif::PCArc* release_arc_to();
  ::uif::PCArc* mutable_arc_to();
  void set_allocated_arc_to(::uif::PCArc* arc_to);
  private:
  const ::uif::PCArc& _internal_arc_to() const;
  ::uif::PCArc* _internal_mutable_arc_to();
  public:
  void unsafe_arena_set_allocated_arc_to(
      ::uif::PCArc* arc_to);
  ::uif::PCArc* unsafe_arena_release_arc_to();

  void clear_cmd();
  CmdCase cmd_case() const;
  // @@protoc_insertion_point(class_scope:uif.PathCommand)
 private:
  class _Internal;
  void set_has_begin();
  void set_has_end();
  void set_has_line_to();
  void set_has_cubic_to();
  void set_has_quad_to();
  void set_has_arc_to();

  inline bool has_cmd() const;
  inline void clear_has_cmd();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union CmdUnion {
    constexpr CmdUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::uif::PCBegin* begin_;
    ::uif::PCEnd* end_;
    ::uif::PCLineTo* line_to_;
    ::uif::PCCubicCurve* cubic_to_;
    ::uif::PCQuadraticCurve* quad_to_;
    ::uif::PCArc* arc_to_;
  } cmd_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_uif_2eproto;
};
// -------------------------------------------------------------------

class PathNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uif.PathNode) */ {
 public:
  inline PathNode() : PathNode(nullptr) {}
  ~PathNode() override;
  explicit constexpr PathNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PathNode(const PathNode& from);
  PathNode(PathNode&& from) noexcept
    : PathNode() {
    *this = ::std::move(from);
  }

  inline PathNode& operator=(const PathNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline PathNode& operator=(PathNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PathNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const PathNode* internal_default_instance() {
    return reinterpret_cast<const PathNode*>(
               &_PathNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(PathNode& a, PathNode& b) {
    a.Swap(&b);
  }
  inline void Swap(PathNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PathNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PathNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PathNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PathNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PathNode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PathNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uif.PathNode";
  }
  protected:
  explicit PathNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommandsFieldNumber = 1,
    kStrokeFieldNumber = 3,
    kIsFilledFieldNumber = 2,
    kStrokeWidthFieldNumber = 4,
  };
  // repeated .uif.PathCommand commands = 1;
  int commands_size() const;
  private:
  int _internal_commands_size() const;
  public:
  void clear_commands();
  ::uif::PathCommand* mutable_commands(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::uif::PathCommand >*
      mutable_commands();
  private:
  const ::uif::PathCommand& _internal_commands(int index) const;
  ::uif::PathCommand* _internal_add_commands();
  public:
  const ::uif::PathCommand& commands(int index) const;
  ::uif::PathCommand* add_commands();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::uif::PathCommand >&
      commands() const;

  // .uif.Brush stroke = 3;
  bool has_stroke() const;
  private:
  bool _internal_has_stroke() const;
  public:
  void clear_stroke();
  const ::uif::Brush& stroke() const;
  PROTOBUF_NODISCARD ::uif::Brush* release_stroke();
  ::uif::Brush* mutable_stroke();
  void set_allocated_stroke(::uif::Brush* stroke);
  private:
  const ::uif::Brush& _internal_stroke() const;
  ::uif::Brush* _internal_mutable_stroke();
  public:
  void unsafe_arena_set_allocated_stroke(
      ::uif::Brush* stroke);
  ::uif::Brush* unsafe_arena_release_stroke();

  // bool is_filled = 2;
  void clear_is_filled();
  bool is_filled() const;
  void set_is_filled(bool value);
  private:
  bool _internal_is_filled() const;
  void _internal_set_is_filled(bool value);
  public:

  // float stroke_width = 4;
  void clear_stroke_width();
  float stroke_width() const;
  void set_stroke_width(float value);
  private:
  float _internal_stroke_width() const;
  void _internal_set_stroke_width(float value);
  public:

  // @@protoc_insertion_point(class_scope:uif.PathNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::uif::PathCommand > commands_;
  ::uif::Brush* stroke_;
  bool is_filled_;
  float stroke_width_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_uif_2eproto;
};
// -------------------------------------------------------------------

class EmptyNode final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:uif.EmptyNode) */ {
 public:
  inline EmptyNode() : EmptyNode(nullptr) {}
  explicit constexpr EmptyNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EmptyNode(const EmptyNode& from);
  EmptyNode(EmptyNode&& from) noexcept
    : EmptyNode() {
    *this = ::std::move(from);
  }

  inline EmptyNode& operator=(const EmptyNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmptyNode& operator=(EmptyNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmptyNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmptyNode* internal_default_instance() {
    return reinterpret_cast<const EmptyNode*>(
               &_EmptyNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(EmptyNode& a, EmptyNode& b) {
    a.Swap(&b);
  }
  inline void Swap(EmptyNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmptyNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmptyNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EmptyNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const EmptyNode& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const EmptyNode& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uif.EmptyNode";
  }
  protected:
  explicit EmptyNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:uif.EmptyNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_uif_2eproto;
};
// -------------------------------------------------------------------

class ClipRectNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uif.ClipRectNode) */ {
 public:
  inline ClipRectNode() : ClipRectNode(nullptr) {}
  ~ClipRectNode() override;
  explicit constexpr ClipRectNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClipRectNode(const ClipRectNode& from);
  ClipRectNode(ClipRectNode&& from) noexcept
    : ClipRectNode() {
    *this = ::std::move(from);
  }

  inline ClipRectNode& operator=(const ClipRectNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClipRectNode& operator=(ClipRectNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClipRectNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClipRectNode* internal_default_instance() {
    return reinterpret_cast<const ClipRectNode*>(
               &_ClipRectNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ClipRectNode& a, ClipRectNode& b) {
    a.Swap(&b);
  }
  inline void Swap(ClipRectNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClipRectNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClipRectNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClipRectNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClipRectNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ClipRectNode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClipRectNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uif.ClipRectNode";
  }
  protected:
  explicit ClipRectNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRectFieldNumber = 1,
  };
  // .uif.Rectangle rect = 1;
  bool has_rect() const;
  private:
  bool _internal_has_rect() const;
  public:
  void clear_rect();
  const ::uif::Rectangle& rect() const;
  PROTOBUF_NODISCARD ::uif::Rectangle* release_rect();
  ::uif::Rectangle* mutable_rect();
  void set_allocated_rect(::uif::Rectangle* rect);
  private:
  const ::uif::Rectangle& _internal_rect() const;
  ::uif::Rectangle* _internal_mutable_rect();
  public:
  void unsafe_arena_set_allocated_rect(
      ::uif::Rectangle* rect);
  ::uif::Rectangle* unsafe_arena_release_rect();

  // @@protoc_insertion_point(class_scope:uif.ClipRectNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::uif::Rectangle* rect_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_uif_2eproto;
};
// -------------------------------------------------------------------

class EditCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uif.EditCommand) */ {
 public:
  inline EditCommand() : EditCommand(nullptr) {}
  ~EditCommand() override;
  explicit constexpr EditCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditCommand(const EditCommand& from);
  EditCommand(EditCommand&& from) noexcept
    : EditCommand() {
    *this = ::std::move(from);
  }

  inline EditCommand& operator=(const EditCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditCommand& operator=(EditCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditCommand& default_instance() {
    return *internal_default_instance();
  }
  enum NodeCase {
    kRect = 10,
    kText = 11,
    kPath = 12,
    kEmpty = 20,
    kClip = 21,
    NODE_NOT_SET = 0,
  };

  static inline const EditCommand* internal_default_instance() {
    return reinterpret_cast<const EditCommand*>(
               &_EditCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(EditCommand& a, EditCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(EditCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EditCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditCommand* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uif.EditCommand";
  }
  protected:
  explicit EditCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef EditCommand_EditKind EditKind;
  static constexpr EditKind APPEND_CHILD =
    EditCommand_EditKind_APPEND_CHILD;
  static constexpr EditKind REPLACE_NODE =
    EditCommand_EditKind_REPLACE_NODE;
  static constexpr EditKind CLEANUP_CLIENT =
    EditCommand_EditKind_CLEANUP_CLIENT;
  static constexpr EditKind DELETE_OBJECT =
    EditCommand_EditKind_DELETE_OBJECT;
  static inline bool EditKind_IsValid(int value) {
    return EditCommand_EditKind_IsValid(value);
  }
  static constexpr EditKind EditKind_MIN =
    EditCommand_EditKind_EditKind_MIN;
  static constexpr EditKind EditKind_MAX =
    EditCommand_EditKind_EditKind_MAX;
  static constexpr int EditKind_ARRAYSIZE =
    EditCommand_EditKind_EditKind_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EditKind_descriptor() {
    return EditCommand_EditKind_descriptor();
  }
  template<typename T>
  static inline const std::string& EditKind_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EditKind>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EditKind_Name.");
    return EditCommand_EditKind_Name(enum_t_value);
  }
  static inline bool EditKind_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EditKind* value) {
    return EditCommand_EditKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 4,
    kParentIdFieldNumber = 2,
    kObjectIdFieldNumber = 3,
    kTimestampFieldNumber = 5,
    kKindFieldNumber = 1,
    kRectFieldNumber = 10,
    kTextFieldNumber = 11,
    kPathFieldNumber = 12,
    kEmptyFieldNumber = 20,
    kClipFieldNumber = 21,
  };
  // string client_id = 4;
  void clear_client_id();
  const std::string& client_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_id();
  PROTOBUF_NODISCARD std::string* release_client_id();
  void set_allocated_client_id(std::string* client_id);
  private:
  const std::string& _internal_client_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_id(const std::string& value);
  std::string* _internal_mutable_client_id();
  public:

  // uint64 parent_id = 2;
  void clear_parent_id();
  uint64_t parent_id() const;
  void set_parent_id(uint64_t value);
  private:
  uint64_t _internal_parent_id() const;
  void _internal_set_parent_id(uint64_t value);
  public:

  // uint64 object_id = 3;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // uint64 timestamp = 5;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // .uif.EditCommand.EditKind kind = 1;
  void clear_kind();
  ::uif::EditCommand_EditKind kind() const;
  void set_kind(::uif::EditCommand_EditKind value);
  private:
  ::uif::EditCommand_EditKind _internal_kind() const;
  void _internal_set_kind(::uif::EditCommand_EditKind value);
  public:

  // .uif.RectangleNode rect = 10;
  bool has_rect() const;
  private:
  bool _internal_has_rect() const;
  public:
  void clear_rect();
  const ::uif::RectangleNode& rect() const;
  PROTOBUF_NODISCARD ::uif::RectangleNode* release_rect();
  ::uif::RectangleNode* mutable_rect();
  void set_allocated_rect(::uif::RectangleNode* rect);
  private:
  const ::uif::RectangleNode& _internal_rect() const;
  ::uif::RectangleNode* _internal_mutable_rect();
  public:
  void unsafe_arena_set_allocated_rect(
      ::uif::RectangleNode* rect);
  ::uif::RectangleNode* unsafe_arena_release_rect();

  // .uif.TextNode text = 11;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const ::uif::TextNode& text() const;
  PROTOBUF_NODISCARD ::uif::TextNode* release_text();
  ::uif::TextNode* mutable_text();
  void set_allocated_text(::uif::TextNode* text);
  private:
  const ::uif::TextNode& _internal_text() const;
  ::uif::TextNode* _internal_mutable_text();
  public:
  void unsafe_arena_set_allocated_text(
      ::uif::TextNode* text);
  ::uif::TextNode* unsafe_arena_release_text();

  // .uif.PathNode path = 12;
  bool has_path() const;
  private:
  bool _internal_has_path() const;
  public:
  void clear_path();
  const ::uif::PathNode& path() const;
  PROTOBUF_NODISCARD ::uif::PathNode* release_path();
  ::uif::PathNode* mutable_path();
  void set_allocated_path(::uif::PathNode* path);
  private:
  const ::uif::PathNode& _internal_path() const;
  ::uif::PathNode* _internal_mutable_path();
  public:
  void unsafe_arena_set_allocated_path(
      ::uif::PathNode* path);
  ::uif::PathNode* unsafe_arena_release_path();

  // .uif.EmptyNode empty = 20;
  bool has_empty() const;
  private:
  bool _internal_has_empty() const;
  public:
  void clear_empty();
  const ::uif::EmptyNode& empty() const;
  PROTOBUF_NODISCARD ::uif::EmptyNode* release_empty();
  ::uif::EmptyNode* mutable_empty();
  void set_allocated_empty(::uif::EmptyNode* empty);
  private:
  const ::uif::EmptyNode& _internal_empty() const;
  ::uif::EmptyNode* _internal_mutable_empty();
  public:
  void unsafe_arena_set_allocated_empty(
      ::uif::EmptyNode* empty);
  ::uif::EmptyNode* unsafe_arena_release_empty();

  // .uif.ClipRectNode clip = 21;
  bool has_clip() const;
  private:
  bool _internal_has_clip() const;
  public:
  void clear_clip();
  const ::uif::ClipRectNode& clip() const;
  PROTOBUF_NODISCARD ::uif::ClipRectNode* release_clip();
  ::uif::ClipRectNode* mutable_clip();
  void set_allocated_clip(::uif::ClipRectNode* clip);
  private:
  const ::uif::ClipRectNode& _internal_clip() const;
  ::uif::ClipRectNode* _internal_mutable_clip();
  public:
  void unsafe_arena_set_allocated_clip(
      ::uif::ClipRectNode* clip);
  ::uif::ClipRectNode* unsafe_arena_release_clip();

  void clear_node();
  NodeCase node_case() const;
  // @@protoc_insertion_point(class_scope:uif.EditCommand)
 private:
  class _Internal;
  void set_has_rect();
  void set_has_text();
  void set_has_path();
  void set_has_empty();
  void set_has_clip();

  inline bool has_node() const;
  inline void clear_has_node();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_id_;
  uint64_t parent_id_;
  uint64_t object_id_;
  uint64_t timestamp_;
  int kind_;
  union NodeUnion {
    constexpr NodeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::uif::RectangleNode* rect_;
    ::uif::TextNode* text_;
    ::uif::PathNode* path_;
    ::uif::EmptyNode* empty_;
    ::uif::ClipRectNode* clip_;
  } node_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_uif_2eproto;
};
// -------------------------------------------------------------------

class EditReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uif.EditReq) */ {
 public:
  inline EditReq() : EditReq(nullptr) {}
  ~EditReq() override;
  explicit constexpr EditReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditReq(const EditReq& from);
  EditReq(EditReq&& from) noexcept
    : EditReq() {
    *this = ::std::move(from);
  }

  inline EditReq& operator=(const EditReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditReq& operator=(EditReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditReq* internal_default_instance() {
    return reinterpret_cast<const EditReq*>(
               &_EditReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(EditReq& a, EditReq& b) {
    a.Swap(&b);
  }
  inline void Swap(EditReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EditReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uif.EditReq";
  }
  protected:
  explicit EditReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommandsFieldNumber = 2,
  };
  // repeated .uif.EditCommand commands = 2;
  int commands_size() const;
  private:
  int _internal_commands_size() const;
  public:
  void clear_commands();
  ::uif::EditCommand* mutable_commands(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::uif::EditCommand >*
      mutable_commands();
  private:
  const ::uif::EditCommand& _internal_commands(int index) const;
  ::uif::EditCommand* _internal_add_commands();
  public:
  const ::uif::EditCommand& commands(int index) const;
  ::uif::EditCommand* add_commands();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::uif::EditCommand >&
      commands() const;

  // @@protoc_insertion_point(class_scope:uif.EditReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::uif::EditCommand > commands_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_uif_2eproto;
};
// -------------------------------------------------------------------

class EditResp final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:uif.EditResp) */ {
 public:
  inline EditResp() : EditResp(nullptr) {}
  explicit constexpr EditResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditResp(const EditResp& from);
  EditResp(EditResp&& from) noexcept
    : EditResp() {
    *this = ::std::move(from);
  }

  inline EditResp& operator=(const EditResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditResp& operator=(EditResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditResp* internal_default_instance() {
    return reinterpret_cast<const EditResp*>(
               &_EditResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(EditResp& a, EditResp& b) {
    a.Swap(&b);
  }
  inline void Swap(EditResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const EditResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const EditResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uif.EditResp";
  }
  protected:
  explicit EditResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:uif.EditResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_uif_2eproto;
};
// -------------------------------------------------------------------

class GetEventsReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uif.GetEventsReq) */ {
 public:
  inline GetEventsReq() : GetEventsReq(nullptr) {}
  ~GetEventsReq() override;
  explicit constexpr GetEventsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetEventsReq(const GetEventsReq& from);
  GetEventsReq(GetEventsReq&& from) noexcept
    : GetEventsReq() {
    *this = ::std::move(from);
  }

  inline GetEventsReq& operator=(const GetEventsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetEventsReq& operator=(GetEventsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetEventsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetEventsReq* internal_default_instance() {
    return reinterpret_cast<const GetEventsReq*>(
               &_GetEventsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(GetEventsReq& a, GetEventsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetEventsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetEventsReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetEventsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetEventsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetEventsReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetEventsReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetEventsReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uif.GetEventsReq";
  }
  protected:
  explicit GetEventsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
  };
  // string client_id = 1;
  void clear_client_id();
  const std::string& client_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_id();
  PROTOBUF_NODISCARD std::string* release_client_id();
  void set_allocated_client_id(std::string* client_id);
  private:
  const std::string& _internal_client_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_id(const std::string& value);
  std::string* _internal_mutable_client_id();
  public:

  // @@protoc_insertion_point(class_scope:uif.GetEventsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_uif_2eproto;
};
// -------------------------------------------------------------------

class CloseEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uif.CloseEvent) */ {
 public:
  inline CloseEvent() : CloseEvent(nullptr) {}
  ~CloseEvent() override;
  explicit constexpr CloseEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CloseEvent(const CloseEvent& from);
  CloseEvent(CloseEvent&& from) noexcept
    : CloseEvent() {
    *this = ::std::move(from);
  }

  inline CloseEvent& operator=(const CloseEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline CloseEvent& operator=(CloseEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CloseEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const CloseEvent* internal_default_instance() {
    return reinterpret_cast<const CloseEvent*>(
               &_CloseEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(CloseEvent& a, CloseEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(CloseEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CloseEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CloseEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CloseEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CloseEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CloseEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CloseEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uif.CloseEvent";
  }
  protected:
  explicit CloseEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClosedFieldNumber = 1,
  };
  // bool closed = 1;
  void clear_closed();
  bool closed() const;
  void set_closed(bool value);
  private:
  bool _internal_closed() const;
  void _internal_set_closed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:uif.CloseEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool closed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_uif_2eproto;
};
// -------------------------------------------------------------------

class MouseEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uif.MouseEvent) */ {
 public:
  inline MouseEvent() : MouseEvent(nullptr) {}
  ~MouseEvent() override;
  explicit constexpr MouseEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MouseEvent(const MouseEvent& from);
  MouseEvent(MouseEvent&& from) noexcept
    : MouseEvent() {
    *this = ::std::move(from);
  }

  inline MouseEvent& operator=(const MouseEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MouseEvent& operator=(MouseEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MouseEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const MouseEvent* internal_default_instance() {
    return reinterpret_cast<const MouseEvent*>(
               &_MouseEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(MouseEvent& a, MouseEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(MouseEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MouseEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MouseEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MouseEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MouseEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MouseEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MouseEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uif.MouseEvent";
  }
  protected:
  explicit MouseEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 3,
    kButtonFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // .uif.Point location = 3;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::uif::Point& location() const;
  PROTOBUF_NODISCARD ::uif::Point* release_location();
  ::uif::Point* mutable_location();
  void set_allocated_location(::uif::Point* location);
  private:
  const ::uif::Point& _internal_location() const;
  ::uif::Point* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::uif::Point* location);
  ::uif::Point* unsafe_arena_release_location();

  // .uif.MouseButton button = 1;
  void clear_button();
  ::uif::MouseButton button() const;
  void set_button(::uif::MouseButton value);
  private:
  ::uif::MouseButton _internal_button() const;
  void _internal_set_button(::uif::MouseButton value);
  public:

  // .uif.MouseState state = 2;
  void clear_state();
  ::uif::MouseState state() const;
  void set_state(::uif::MouseState value);
  private:
  ::uif::MouseState _internal_state() const;
  void _internal_set_state(::uif::MouseState value);
  public:

  // @@protoc_insertion_point(class_scope:uif.MouseEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::uif::Point* location_;
  int button_;
  int state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_uif_2eproto;
};
// -------------------------------------------------------------------

class KeyboardEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uif.KeyboardEvent) */ {
 public:
  inline KeyboardEvent() : KeyboardEvent(nullptr) {}
  ~KeyboardEvent() override;
  explicit constexpr KeyboardEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyboardEvent(const KeyboardEvent& from);
  KeyboardEvent(KeyboardEvent&& from) noexcept
    : KeyboardEvent() {
    *this = ::std::move(from);
  }

  inline KeyboardEvent& operator=(const KeyboardEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyboardEvent& operator=(KeyboardEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyboardEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyboardEvent* internal_default_instance() {
    return reinterpret_cast<const KeyboardEvent*>(
               &_KeyboardEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(KeyboardEvent& a, KeyboardEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyboardEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyboardEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyboardEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeyboardEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KeyboardEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const KeyboardEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyboardEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uif.KeyboardEvent";
  }
  protected:
  explicit KeyboardEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
    kKeyCodeFieldNumber = 2,
  };
  // .uif.KeyState state = 1;
  void clear_state();
  ::uif::KeyState state() const;
  void set_state(::uif::KeyState value);
  private:
  ::uif::KeyState _internal_state() const;
  void _internal_set_state(::uif::KeyState value);
  public:

  // uint32 key_code = 2;
  void clear_key_code();
  uint32_t key_code() const;
  void set_key_code(uint32_t value);
  private:
  uint32_t _internal_key_code() const;
  void _internal_set_key_code(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:uif.KeyboardEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int state_;
  uint32_t key_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_uif_2eproto;
};
// -------------------------------------------------------------------

class TextHitEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uif.TextHitEvent) */ {
 public:
  inline TextHitEvent() : TextHitEvent(nullptr) {}
  ~TextHitEvent() override;
  explicit constexpr TextHitEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TextHitEvent(const TextHitEvent& from);
  TextHitEvent(TextHitEvent&& from) noexcept
    : TextHitEvent() {
    *this = ::std::move(from);
  }

  inline TextHitEvent& operator=(const TextHitEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextHitEvent& operator=(TextHitEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TextHitEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const TextHitEvent* internal_default_instance() {
    return reinterpret_cast<const TextHitEvent*>(
               &_TextHitEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(TextHitEvent& a, TextHitEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(TextHitEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextHitEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TextHitEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TextHitEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TextHitEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TextHitEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextHitEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uif.TextHitEvent";
  }
  protected:
  explicit TextHitEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMouseFieldNumber = 1,
    kOffsetFieldNumber = 2,
    kLengthFieldNumber = 3,
    kObjectIdFieldNumber = 4,
  };
  // .uif.MouseEvent mouse = 1;
  bool has_mouse() const;
  private:
  bool _internal_has_mouse() const;
  public:
  void clear_mouse();
  const ::uif::MouseEvent& mouse() const;
  PROTOBUF_NODISCARD ::uif::MouseEvent* release_mouse();
  ::uif::MouseEvent* mutable_mouse();
  void set_allocated_mouse(::uif::MouseEvent* mouse);
  private:
  const ::uif::MouseEvent& _internal_mouse() const;
  ::uif::MouseEvent* _internal_mutable_mouse();
  public:
  void unsafe_arena_set_allocated_mouse(
      ::uif::MouseEvent* mouse);
  ::uif::MouseEvent* unsafe_arena_release_mouse();

  // uint32 offset = 2;
  void clear_offset();
  uint32_t offset() const;
  void set_offset(uint32_t value);
  private:
  uint32_t _internal_offset() const;
  void _internal_set_offset(uint32_t value);
  public:

  // uint32 length = 3;
  void clear_length();
  uint32_t length() const;
  void set_length(uint32_t value);
  private:
  uint32_t _internal_length() const;
  void _internal_set_length(uint32_t value);
  public:

  // uint64 object_id = 4;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:uif.TextHitEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::uif::MouseEvent* mouse_;
  uint32_t offset_;
  uint32_t length_;
  uint64_t object_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_uif_2eproto;
};
// -------------------------------------------------------------------

class Event final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uif.Event) */ {
 public:
  inline Event() : Event(nullptr) {}
  ~Event() override;
  explicit constexpr Event(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Event(const Event& from);
  Event(Event&& from) noexcept
    : Event() {
    *this = ::std::move(from);
  }

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  inline Event& operator=(Event&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Event& default_instance() {
    return *internal_default_instance();
  }
  enum EventCase {
    kClose = 10,
    kMouse = 11,
    kKey = 12,
    kTextHit = 13,
    EVENT_NOT_SET = 0,
  };

  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(Event& a, Event& b) {
    a.Swap(&b);
  }
  inline void Swap(Event* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Event* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Event* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Event>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Event& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Event& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uif.Event";
  }
  protected:
  explicit Event(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCloseFieldNumber = 10,
    kMouseFieldNumber = 11,
    kKeyFieldNumber = 12,
    kTextHitFieldNumber = 13,
  };
  // .uif.CloseEvent close = 10;
  bool has_close() const;
  private:
  bool _internal_has_close() const;
  public:
  void clear_close();
  const ::uif::CloseEvent& close() const;
  PROTOBUF_NODISCARD ::uif::CloseEvent* release_close();
  ::uif::CloseEvent* mutable_close();
  void set_allocated_close(::uif::CloseEvent* close);
  private:
  const ::uif::CloseEvent& _internal_close() const;
  ::uif::CloseEvent* _internal_mutable_close();
  public:
  void unsafe_arena_set_allocated_close(
      ::uif::CloseEvent* close);
  ::uif::CloseEvent* unsafe_arena_release_close();

  // .uif.MouseEvent mouse = 11;
  bool has_mouse() const;
  private:
  bool _internal_has_mouse() const;
  public:
  void clear_mouse();
  const ::uif::MouseEvent& mouse() const;
  PROTOBUF_NODISCARD ::uif::MouseEvent* release_mouse();
  ::uif::MouseEvent* mutable_mouse();
  void set_allocated_mouse(::uif::MouseEvent* mouse);
  private:
  const ::uif::MouseEvent& _internal_mouse() const;
  ::uif::MouseEvent* _internal_mutable_mouse();
  public:
  void unsafe_arena_set_allocated_mouse(
      ::uif::MouseEvent* mouse);
  ::uif::MouseEvent* unsafe_arena_release_mouse();

  // .uif.KeyboardEvent key = 12;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::uif::KeyboardEvent& key() const;
  PROTOBUF_NODISCARD ::uif::KeyboardEvent* release_key();
  ::uif::KeyboardEvent* mutable_key();
  void set_allocated_key(::uif::KeyboardEvent* key);
  private:
  const ::uif::KeyboardEvent& _internal_key() const;
  ::uif::KeyboardEvent* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::uif::KeyboardEvent* key);
  ::uif::KeyboardEvent* unsafe_arena_release_key();

  // .uif.TextHitEvent textHit = 13;
  bool has_texthit() const;
  private:
  bool _internal_has_texthit() const;
  public:
  void clear_texthit();
  const ::uif::TextHitEvent& texthit() const;
  PROTOBUF_NODISCARD ::uif::TextHitEvent* release_texthit();
  ::uif::TextHitEvent* mutable_texthit();
  void set_allocated_texthit(::uif::TextHitEvent* texthit);
  private:
  const ::uif::TextHitEvent& _internal_texthit() const;
  ::uif::TextHitEvent* _internal_mutable_texthit();
  public:
  void unsafe_arena_set_allocated_texthit(
      ::uif::TextHitEvent* texthit);
  ::uif::TextHitEvent* unsafe_arena_release_texthit();

  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:uif.Event)
 private:
  class _Internal;
  void set_has_close();
  void set_has_mouse();
  void set_has_key();
  void set_has_texthit();

  inline bool has_event() const;
  inline void clear_has_event();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union EventUnion {
    constexpr EventUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::uif::CloseEvent* close_;
    ::uif::MouseEvent* mouse_;
    ::uif::KeyboardEvent* key_;
    ::uif::TextHitEvent* texthit_;
  } event_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_uif_2eproto;
};
// -------------------------------------------------------------------

class GetServerPropertiesReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:uif.GetServerPropertiesReq) */ {
 public:
  inline GetServerPropertiesReq() : GetServerPropertiesReq(nullptr) {}
  explicit constexpr GetServerPropertiesReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetServerPropertiesReq(const GetServerPropertiesReq& from);
  GetServerPropertiesReq(GetServerPropertiesReq&& from) noexcept
    : GetServerPropertiesReq() {
    *this = ::std::move(from);
  }

  inline GetServerPropertiesReq& operator=(const GetServerPropertiesReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetServerPropertiesReq& operator=(GetServerPropertiesReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetServerPropertiesReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetServerPropertiesReq* internal_default_instance() {
    return reinterpret_cast<const GetServerPropertiesReq*>(
               &_GetServerPropertiesReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(GetServerPropertiesReq& a, GetServerPropertiesReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetServerPropertiesReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetServerPropertiesReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetServerPropertiesReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetServerPropertiesReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetServerPropertiesReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetServerPropertiesReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uif.GetServerPropertiesReq";
  }
  protected:
  explicit GetServerPropertiesReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:uif.GetServerPropertiesReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_uif_2eproto;
};
// -------------------------------------------------------------------

class GetServerPropertiesResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uif.GetServerPropertiesResp) */ {
 public:
  inline GetServerPropertiesResp() : GetServerPropertiesResp(nullptr) {}
  ~GetServerPropertiesResp() override;
  explicit constexpr GetServerPropertiesResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetServerPropertiesResp(const GetServerPropertiesResp& from);
  GetServerPropertiesResp(GetServerPropertiesResp&& from) noexcept
    : GetServerPropertiesResp() {
    *this = ::std::move(from);
  }

  inline GetServerPropertiesResp& operator=(const GetServerPropertiesResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetServerPropertiesResp& operator=(GetServerPropertiesResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetServerPropertiesResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetServerPropertiesResp* internal_default_instance() {
    return reinterpret_cast<const GetServerPropertiesResp*>(
               &_GetServerPropertiesResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(GetServerPropertiesResp& a, GetServerPropertiesResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetServerPropertiesResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetServerPropertiesResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetServerPropertiesResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetServerPropertiesResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetServerPropertiesResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetServerPropertiesResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetServerPropertiesResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uif.GetServerPropertiesResp";
  }
  protected:
  explicit GetServerPropertiesResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWindowWidthFieldNumber = 1,
    kWindowHeightFieldNumber = 2,
  };
  // uint32 window_width = 1;
  void clear_window_width();
  uint32_t window_width() const;
  void set_window_width(uint32_t value);
  private:
  uint32_t _internal_window_width() const;
  void _internal_set_window_width(uint32_t value);
  public:

  // uint32 window_height = 2;
  void clear_window_height();
  uint32_t window_height() const;
  void set_window_height(uint32_t value);
  private:
  uint32_t _internal_window_height() const;
  void _internal_set_window_height(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:uif.GetServerPropertiesResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t window_width_;
  uint32_t window_height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_uif_2eproto;
};
// -------------------------------------------------------------------

class SetClearColorReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uif.SetClearColorReq) */ {
 public:
  inline SetClearColorReq() : SetClearColorReq(nullptr) {}
  ~SetClearColorReq() override;
  explicit constexpr SetClearColorReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetClearColorReq(const SetClearColorReq& from);
  SetClearColorReq(SetClearColorReq&& from) noexcept
    : SetClearColorReq() {
    *this = ::std::move(from);
  }

  inline SetClearColorReq& operator=(const SetClearColorReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetClearColorReq& operator=(SetClearColorReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetClearColorReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetClearColorReq* internal_default_instance() {
    return reinterpret_cast<const SetClearColorReq*>(
               &_SetClearColorReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(SetClearColorReq& a, SetClearColorReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SetClearColorReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetClearColorReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetClearColorReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetClearColorReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetClearColorReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetClearColorReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetClearColorReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uif.SetClearColorReq";
  }
  protected:
  explicit SetClearColorReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 1,
  };
  // uint32 color = 1;
  void clear_color();
  uint32_t color() const;
  void set_color(uint32_t value);
  private:
  uint32_t _internal_color() const;
  void _internal_set_color(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:uif.SetClearColorReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t color_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_uif_2eproto;
};
// -------------------------------------------------------------------

class SetClearColorResp final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:uif.SetClearColorResp) */ {
 public:
  inline SetClearColorResp() : SetClearColorResp(nullptr) {}
  explicit constexpr SetClearColorResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetClearColorResp(const SetClearColorResp& from);
  SetClearColorResp(SetClearColorResp&& from) noexcept
    : SetClearColorResp() {
    *this = ::std::move(from);
  }

  inline SetClearColorResp& operator=(const SetClearColorResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetClearColorResp& operator=(SetClearColorResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetClearColorResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetClearColorResp* internal_default_instance() {
    return reinterpret_cast<const SetClearColorResp*>(
               &_SetClearColorResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(SetClearColorResp& a, SetClearColorResp& b) {
    a.Swap(&b);
  }
  inline void Swap(SetClearColorResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetClearColorResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetClearColorResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetClearColorResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetClearColorResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetClearColorResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uif.SetClearColorResp";
  }
  protected:
  explicit SetClearColorResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:uif.SetClearColorResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_uif_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Point

// float x = 1;
inline void Point::clear_x() {
  x_ = 0;
}
inline float Point::_internal_x() const {
  return x_;
}
inline float Point::x() const {
  // @@protoc_insertion_point(field_get:uif.Point.x)
  return _internal_x();
}
inline void Point::_internal_set_x(float value) {
  
  x_ = value;
}
inline void Point::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:uif.Point.x)
}

// float y = 2;
inline void Point::clear_y() {
  y_ = 0;
}
inline float Point::_internal_y() const {
  return y_;
}
inline float Point::y() const {
  // @@protoc_insertion_point(field_get:uif.Point.y)
  return _internal_y();
}
inline void Point::_internal_set_y(float value) {
  
  y_ = value;
}
inline void Point::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:uif.Point.y)
}

// -------------------------------------------------------------------

// Rectangle

// float x = 1;
inline void Rectangle::clear_x() {
  x_ = 0;
}
inline float Rectangle::_internal_x() const {
  return x_;
}
inline float Rectangle::x() const {
  // @@protoc_insertion_point(field_get:uif.Rectangle.x)
  return _internal_x();
}
inline void Rectangle::_internal_set_x(float value) {
  
  x_ = value;
}
inline void Rectangle::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:uif.Rectangle.x)
}

// float y = 2;
inline void Rectangle::clear_y() {
  y_ = 0;
}
inline float Rectangle::_internal_y() const {
  return y_;
}
inline float Rectangle::y() const {
  // @@protoc_insertion_point(field_get:uif.Rectangle.y)
  return _internal_y();
}
inline void Rectangle::_internal_set_y(float value) {
  
  y_ = value;
}
inline void Rectangle::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:uif.Rectangle.y)
}

// float width = 3;
inline void Rectangle::clear_width() {
  width_ = 0;
}
inline float Rectangle::_internal_width() const {
  return width_;
}
inline float Rectangle::width() const {
  // @@protoc_insertion_point(field_get:uif.Rectangle.width)
  return _internal_width();
}
inline void Rectangle::_internal_set_width(float value) {
  
  width_ = value;
}
inline void Rectangle::set_width(float value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:uif.Rectangle.width)
}

// float height = 4;
inline void Rectangle::clear_height() {
  height_ = 0;
}
inline float Rectangle::_internal_height() const {
  return height_;
}
inline float Rectangle::height() const {
  // @@protoc_insertion_point(field_get:uif.Rectangle.height)
  return _internal_height();
}
inline void Rectangle::_internal_set_height(float value) {
  
  height_ = value;
}
inline void Rectangle::set_height(float value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:uif.Rectangle.height)
}

// -------------------------------------------------------------------

// SolidBrush

// uint32 color = 1;
inline void SolidBrush::clear_color() {
  color_ = 0u;
}
inline uint32_t SolidBrush::_internal_color() const {
  return color_;
}
inline uint32_t SolidBrush::color() const {
  // @@protoc_insertion_point(field_get:uif.SolidBrush.color)
  return _internal_color();
}
inline void SolidBrush::_internal_set_color(uint32_t value) {
  
  color_ = value;
}
inline void SolidBrush::set_color(uint32_t value) {
  _internal_set_color(value);
  // @@protoc_insertion_point(field_set:uif.SolidBrush.color)
}

// -------------------------------------------------------------------

// GradientStop

// uint32 color = 1;
inline void GradientStop::clear_color() {
  color_ = 0u;
}
inline uint32_t GradientStop::_internal_color() const {
  return color_;
}
inline uint32_t GradientStop::color() const {
  // @@protoc_insertion_point(field_get:uif.GradientStop.color)
  return _internal_color();
}
inline void GradientStop::_internal_set_color(uint32_t value) {
  
  color_ = value;
}
inline void GradientStop::set_color(uint32_t value) {
  _internal_set_color(value);
  // @@protoc_insertion_point(field_set:uif.GradientStop.color)
}

// float position = 2;
inline void GradientStop::clear_position() {
  position_ = 0;
}
inline float GradientStop::_internal_position() const {
  return position_;
}
inline float GradientStop::position() const {
  // @@protoc_insertion_point(field_get:uif.GradientStop.position)
  return _internal_position();
}
inline void GradientStop::_internal_set_position(float value) {
  
  position_ = value;
}
inline void GradientStop::set_position(float value) {
  _internal_set_position(value);
  // @@protoc_insertion_point(field_set:uif.GradientStop.position)
}

// -------------------------------------------------------------------

// LinearGradientBrush

// repeated .uif.GradientStop stops = 1;
inline int LinearGradientBrush::_internal_stops_size() const {
  return stops_.size();
}
inline int LinearGradientBrush::stops_size() const {
  return _internal_stops_size();
}
inline void LinearGradientBrush::clear_stops() {
  stops_.Clear();
}
inline ::uif::GradientStop* LinearGradientBrush::mutable_stops(int index) {
  // @@protoc_insertion_point(field_mutable:uif.LinearGradientBrush.stops)
  return stops_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::uif::GradientStop >*
LinearGradientBrush::mutable_stops() {
  // @@protoc_insertion_point(field_mutable_list:uif.LinearGradientBrush.stops)
  return &stops_;
}
inline const ::uif::GradientStop& LinearGradientBrush::_internal_stops(int index) const {
  return stops_.Get(index);
}
inline const ::uif::GradientStop& LinearGradientBrush::stops(int index) const {
  // @@protoc_insertion_point(field_get:uif.LinearGradientBrush.stops)
  return _internal_stops(index);
}
inline ::uif::GradientStop* LinearGradientBrush::_internal_add_stops() {
  return stops_.Add();
}
inline ::uif::GradientStop* LinearGradientBrush::add_stops() {
  ::uif::GradientStop* _add = _internal_add_stops();
  // @@protoc_insertion_point(field_add:uif.LinearGradientBrush.stops)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::uif::GradientStop >&
LinearGradientBrush::stops() const {
  // @@protoc_insertion_point(field_list:uif.LinearGradientBrush.stops)
  return stops_;
}

// .uif.Point start = 2;
inline bool LinearGradientBrush::_internal_has_start() const {
  return this != internal_default_instance() && start_ != nullptr;
}
inline bool LinearGradientBrush::has_start() const {
  return _internal_has_start();
}
inline void LinearGradientBrush::clear_start() {
  if (GetArenaForAllocation() == nullptr && start_ != nullptr) {
    delete start_;
  }
  start_ = nullptr;
}
inline const ::uif::Point& LinearGradientBrush::_internal_start() const {
  const ::uif::Point* p = start_;
  return p != nullptr ? *p : reinterpret_cast<const ::uif::Point&>(
      ::uif::_Point_default_instance_);
}
inline const ::uif::Point& LinearGradientBrush::start() const {
  // @@protoc_insertion_point(field_get:uif.LinearGradientBrush.start)
  return _internal_start();
}
inline void LinearGradientBrush::unsafe_arena_set_allocated_start(
    ::uif::Point* start) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_);
  }
  start_ = start;
  if (start) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uif.LinearGradientBrush.start)
}
inline ::uif::Point* LinearGradientBrush::release_start() {
  
  ::uif::Point* temp = start_;
  start_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uif::Point* LinearGradientBrush::unsafe_arena_release_start() {
  // @@protoc_insertion_point(field_release:uif.LinearGradientBrush.start)
  
  ::uif::Point* temp = start_;
  start_ = nullptr;
  return temp;
}
inline ::uif::Point* LinearGradientBrush::_internal_mutable_start() {
  
  if (start_ == nullptr) {
    auto* p = CreateMaybeMessage<::uif::Point>(GetArenaForAllocation());
    start_ = p;
  }
  return start_;
}
inline ::uif::Point* LinearGradientBrush::mutable_start() {
  ::uif::Point* _msg = _internal_mutable_start();
  // @@protoc_insertion_point(field_mutable:uif.LinearGradientBrush.start)
  return _msg;
}
inline void LinearGradientBrush::set_allocated_start(::uif::Point* start) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete start_;
  }
  if (start) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::uif::Point>::GetOwningArena(start);
    if (message_arena != submessage_arena) {
      start = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start, submessage_arena);
    }
    
  } else {
    
  }
  start_ = start;
  // @@protoc_insertion_point(field_set_allocated:uif.LinearGradientBrush.start)
}

// .uif.Point end = 3;
inline bool LinearGradientBrush::_internal_has_end() const {
  return this != internal_default_instance() && end_ != nullptr;
}
inline bool LinearGradientBrush::has_end() const {
  return _internal_has_end();
}
inline void LinearGradientBrush::clear_end() {
  if (GetArenaForAllocation() == nullptr && end_ != nullptr) {
    delete end_;
  }
  end_ = nullptr;
}
inline const ::uif::Point& LinearGradientBrush::_internal_end() const {
  const ::uif::Point* p = end_;
  return p != nullptr ? *p : reinterpret_cast<const ::uif::Point&>(
      ::uif::_Point_default_instance_);
}
inline const ::uif::Point& LinearGradientBrush::end() const {
  // @@protoc_insertion_point(field_get:uif.LinearGradientBrush.end)
  return _internal_end();
}
inline void LinearGradientBrush::unsafe_arena_set_allocated_end(
    ::uif::Point* end) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_);
  }
  end_ = end;
  if (end) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uif.LinearGradientBrush.end)
}
inline ::uif::Point* LinearGradientBrush::release_end() {
  
  ::uif::Point* temp = end_;
  end_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uif::Point* LinearGradientBrush::unsafe_arena_release_end() {
  // @@protoc_insertion_point(field_release:uif.LinearGradientBrush.end)
  
  ::uif::Point* temp = end_;
  end_ = nullptr;
  return temp;
}
inline ::uif::Point* LinearGradientBrush::_internal_mutable_end() {
  
  if (end_ == nullptr) {
    auto* p = CreateMaybeMessage<::uif::Point>(GetArenaForAllocation());
    end_ = p;
  }
  return end_;
}
inline ::uif::Point* LinearGradientBrush::mutable_end() {
  ::uif::Point* _msg = _internal_mutable_end();
  // @@protoc_insertion_point(field_mutable:uif.LinearGradientBrush.end)
  return _msg;
}
inline void LinearGradientBrush::set_allocated_end(::uif::Point* end) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete end_;
  }
  if (end) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::uif::Point>::GetOwningArena(end);
    if (message_arena != submessage_arena) {
      end = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end, submessage_arena);
    }
    
  } else {
    
  }
  end_ = end;
  // @@protoc_insertion_point(field_set_allocated:uif.LinearGradientBrush.end)
}

// -------------------------------------------------------------------

// Brush

// .uif.SolidBrush solid = 1;
inline bool Brush::_internal_has_solid() const {
  return kind_case() == kSolid;
}
inline bool Brush::has_solid() const {
  return _internal_has_solid();
}
inline void Brush::set_has_solid() {
  _oneof_case_[0] = kSolid;
}
inline void Brush::clear_solid() {
  if (_internal_has_solid()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.solid_;
    }
    clear_has_kind();
  }
}
inline ::uif::SolidBrush* Brush::release_solid() {
  // @@protoc_insertion_point(field_release:uif.Brush.solid)
  if (_internal_has_solid()) {
    clear_has_kind();
      ::uif::SolidBrush* temp = kind_.solid_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.solid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::uif::SolidBrush& Brush::_internal_solid() const {
  return _internal_has_solid()
      ? *kind_.solid_
      : reinterpret_cast< ::uif::SolidBrush&>(::uif::_SolidBrush_default_instance_);
}
inline const ::uif::SolidBrush& Brush::solid() const {
  // @@protoc_insertion_point(field_get:uif.Brush.solid)
  return _internal_solid();
}
inline ::uif::SolidBrush* Brush::unsafe_arena_release_solid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:uif.Brush.solid)
  if (_internal_has_solid()) {
    clear_has_kind();
    ::uif::SolidBrush* temp = kind_.solid_;
    kind_.solid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Brush::unsafe_arena_set_allocated_solid(::uif::SolidBrush* solid) {
  clear_kind();
  if (solid) {
    set_has_solid();
    kind_.solid_ = solid;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uif.Brush.solid)
}
inline ::uif::SolidBrush* Brush::_internal_mutable_solid() {
  if (!_internal_has_solid()) {
    clear_kind();
    set_has_solid();
    kind_.solid_ = CreateMaybeMessage< ::uif::SolidBrush >(GetArenaForAllocation());
  }
  return kind_.solid_;
}
inline ::uif::SolidBrush* Brush::mutable_solid() {
  ::uif::SolidBrush* _msg = _internal_mutable_solid();
  // @@protoc_insertion_point(field_mutable:uif.Brush.solid)
  return _msg;
}

// .uif.LinearGradientBrush linear = 2;
inline bool Brush::_internal_has_linear() const {
  return kind_case() == kLinear;
}
inline bool Brush::has_linear() const {
  return _internal_has_linear();
}
inline void Brush::set_has_linear() {
  _oneof_case_[0] = kLinear;
}
inline void Brush::clear_linear() {
  if (_internal_has_linear()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.linear_;
    }
    clear_has_kind();
  }
}
inline ::uif::LinearGradientBrush* Brush::release_linear() {
  // @@protoc_insertion_point(field_release:uif.Brush.linear)
  if (_internal_has_linear()) {
    clear_has_kind();
      ::uif::LinearGradientBrush* temp = kind_.linear_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.linear_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::uif::LinearGradientBrush& Brush::_internal_linear() const {
  return _internal_has_linear()
      ? *kind_.linear_
      : reinterpret_cast< ::uif::LinearGradientBrush&>(::uif::_LinearGradientBrush_default_instance_);
}
inline const ::uif::LinearGradientBrush& Brush::linear() const {
  // @@protoc_insertion_point(field_get:uif.Brush.linear)
  return _internal_linear();
}
inline ::uif::LinearGradientBrush* Brush::unsafe_arena_release_linear() {
  // @@protoc_insertion_point(field_unsafe_arena_release:uif.Brush.linear)
  if (_internal_has_linear()) {
    clear_has_kind();
    ::uif::LinearGradientBrush* temp = kind_.linear_;
    kind_.linear_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Brush::unsafe_arena_set_allocated_linear(::uif::LinearGradientBrush* linear) {
  clear_kind();
  if (linear) {
    set_has_linear();
    kind_.linear_ = linear;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uif.Brush.linear)
}
inline ::uif::LinearGradientBrush* Brush::_internal_mutable_linear() {
  if (!_internal_has_linear()) {
    clear_kind();
    set_has_linear();
    kind_.linear_ = CreateMaybeMessage< ::uif::LinearGradientBrush >(GetArenaForAllocation());
  }
  return kind_.linear_;
}
inline ::uif::LinearGradientBrush* Brush::mutable_linear() {
  ::uif::LinearGradientBrush* _msg = _internal_mutable_linear();
  // @@protoc_insertion_point(field_mutable:uif.Brush.linear)
  return _msg;
}

inline bool Brush::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void Brush::clear_has_kind() {
  _oneof_case_[0] = KIND_NOT_SET;
}
inline Brush::KindCase Brush::kind_case() const {
  return Brush::KindCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RectangleNode

// .uif.Rectangle rect = 1;
inline bool RectangleNode::_internal_has_rect() const {
  return this != internal_default_instance() && rect_ != nullptr;
}
inline bool RectangleNode::has_rect() const {
  return _internal_has_rect();
}
inline void RectangleNode::clear_rect() {
  if (GetArenaForAllocation() == nullptr && rect_ != nullptr) {
    delete rect_;
  }
  rect_ = nullptr;
}
inline const ::uif::Rectangle& RectangleNode::_internal_rect() const {
  const ::uif::Rectangle* p = rect_;
  return p != nullptr ? *p : reinterpret_cast<const ::uif::Rectangle&>(
      ::uif::_Rectangle_default_instance_);
}
inline const ::uif::Rectangle& RectangleNode::rect() const {
  // @@protoc_insertion_point(field_get:uif.RectangleNode.rect)
  return _internal_rect();
}
inline void RectangleNode::unsafe_arena_set_allocated_rect(
    ::uif::Rectangle* rect) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rect_);
  }
  rect_ = rect;
  if (rect) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uif.RectangleNode.rect)
}
inline ::uif::Rectangle* RectangleNode::release_rect() {
  
  ::uif::Rectangle* temp = rect_;
  rect_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uif::Rectangle* RectangleNode::unsafe_arena_release_rect() {
  // @@protoc_insertion_point(field_release:uif.RectangleNode.rect)
  
  ::uif::Rectangle* temp = rect_;
  rect_ = nullptr;
  return temp;
}
inline ::uif::Rectangle* RectangleNode::_internal_mutable_rect() {
  
  if (rect_ == nullptr) {
    auto* p = CreateMaybeMessage<::uif::Rectangle>(GetArenaForAllocation());
    rect_ = p;
  }
  return rect_;
}
inline ::uif::Rectangle* RectangleNode::mutable_rect() {
  ::uif::Rectangle* _msg = _internal_mutable_rect();
  // @@protoc_insertion_point(field_mutable:uif.RectangleNode.rect)
  return _msg;
}
inline void RectangleNode::set_allocated_rect(::uif::Rectangle* rect) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rect_;
  }
  if (rect) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::uif::Rectangle>::GetOwningArena(rect);
    if (message_arena != submessage_arena) {
      rect = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rect, submessage_arena);
    }
    
  } else {
    
  }
  rect_ = rect;
  // @@protoc_insertion_point(field_set_allocated:uif.RectangleNode.rect)
}

// .uif.Brush stroke = 2;
inline bool RectangleNode::_internal_has_stroke() const {
  return this != internal_default_instance() && stroke_ != nullptr;
}
inline bool RectangleNode::has_stroke() const {
  return _internal_has_stroke();
}
inline void RectangleNode::clear_stroke() {
  if (GetArenaForAllocation() == nullptr && stroke_ != nullptr) {
    delete stroke_;
  }
  stroke_ = nullptr;
}
inline const ::uif::Brush& RectangleNode::_internal_stroke() const {
  const ::uif::Brush* p = stroke_;
  return p != nullptr ? *p : reinterpret_cast<const ::uif::Brush&>(
      ::uif::_Brush_default_instance_);
}
inline const ::uif::Brush& RectangleNode::stroke() const {
  // @@protoc_insertion_point(field_get:uif.RectangleNode.stroke)
  return _internal_stroke();
}
inline void RectangleNode::unsafe_arena_set_allocated_stroke(
    ::uif::Brush* stroke) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stroke_);
  }
  stroke_ = stroke;
  if (stroke) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uif.RectangleNode.stroke)
}
inline ::uif::Brush* RectangleNode::release_stroke() {
  
  ::uif::Brush* temp = stroke_;
  stroke_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uif::Brush* RectangleNode::unsafe_arena_release_stroke() {
  // @@protoc_insertion_point(field_release:uif.RectangleNode.stroke)
  
  ::uif::Brush* temp = stroke_;
  stroke_ = nullptr;
  return temp;
}
inline ::uif::Brush* RectangleNode::_internal_mutable_stroke() {
  
  if (stroke_ == nullptr) {
    auto* p = CreateMaybeMessage<::uif::Brush>(GetArenaForAllocation());
    stroke_ = p;
  }
  return stroke_;
}
inline ::uif::Brush* RectangleNode::mutable_stroke() {
  ::uif::Brush* _msg = _internal_mutable_stroke();
  // @@protoc_insertion_point(field_mutable:uif.RectangleNode.stroke)
  return _msg;
}
inline void RectangleNode::set_allocated_stroke(::uif::Brush* stroke) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete stroke_;
  }
  if (stroke) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::uif::Brush>::GetOwningArena(stroke);
    if (message_arena != submessage_arena) {
      stroke = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stroke, submessage_arena);
    }
    
  } else {
    
  }
  stroke_ = stroke;
  // @@protoc_insertion_point(field_set_allocated:uif.RectangleNode.stroke)
}

// bool filled = 3;
inline void RectangleNode::clear_filled() {
  filled_ = false;
}
inline bool RectangleNode::_internal_filled() const {
  return filled_;
}
inline bool RectangleNode::filled() const {
  // @@protoc_insertion_point(field_get:uif.RectangleNode.filled)
  return _internal_filled();
}
inline void RectangleNode::_internal_set_filled(bool value) {
  
  filled_ = value;
}
inline void RectangleNode::set_filled(bool value) {
  _internal_set_filled(value);
  // @@protoc_insertion_point(field_set:uif.RectangleNode.filled)
}

// float stroke_width = 6;
inline void RectangleNode::clear_stroke_width() {
  stroke_width_ = 0;
}
inline float RectangleNode::_internal_stroke_width() const {
  return stroke_width_;
}
inline float RectangleNode::stroke_width() const {
  // @@protoc_insertion_point(field_get:uif.RectangleNode.stroke_width)
  return _internal_stroke_width();
}
inline void RectangleNode::_internal_set_stroke_width(float value) {
  
  stroke_width_ = value;
}
inline void RectangleNode::set_stroke_width(float value) {
  _internal_set_stroke_width(value);
  // @@protoc_insertion_point(field_set:uif.RectangleNode.stroke_width)
}

// float rounded_radius_x = 4;
inline void RectangleNode::clear_rounded_radius_x() {
  rounded_radius_x_ = 0;
}
inline float RectangleNode::_internal_rounded_radius_x() const {
  return rounded_radius_x_;
}
inline float RectangleNode::rounded_radius_x() const {
  // @@protoc_insertion_point(field_get:uif.RectangleNode.rounded_radius_x)
  return _internal_rounded_radius_x();
}
inline void RectangleNode::_internal_set_rounded_radius_x(float value) {
  
  rounded_radius_x_ = value;
}
inline void RectangleNode::set_rounded_radius_x(float value) {
  _internal_set_rounded_radius_x(value);
  // @@protoc_insertion_point(field_set:uif.RectangleNode.rounded_radius_x)
}

// float rounded_radius_y = 5;
inline void RectangleNode::clear_rounded_radius_y() {
  rounded_radius_y_ = 0;
}
inline float RectangleNode::_internal_rounded_radius_y() const {
  return rounded_radius_y_;
}
inline float RectangleNode::rounded_radius_y() const {
  // @@protoc_insertion_point(field_get:uif.RectangleNode.rounded_radius_y)
  return _internal_rounded_radius_y();
}
inline void RectangleNode::_internal_set_rounded_radius_y(float value) {
  
  rounded_radius_y_ = value;
}
inline void RectangleNode::set_rounded_radius_y(float value) {
  _internal_set_rounded_radius_y(value);
  // @@protoc_insertion_point(field_set:uif.RectangleNode.rounded_radius_y)
}

// -------------------------------------------------------------------

// TextEditSpan

// int32 offset = 1;
inline void TextEditSpan::clear_offset() {
  offset_ = 0;
}
inline int32_t TextEditSpan::_internal_offset() const {
  return offset_;
}
inline int32_t TextEditSpan::offset() const {
  // @@protoc_insertion_point(field_get:uif.TextEditSpan.offset)
  return _internal_offset();
}
inline void TextEditSpan::_internal_set_offset(int32_t value) {
  
  offset_ = value;
}
inline void TextEditSpan::set_offset(int32_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:uif.TextEditSpan.offset)
}

// int32 length = 2;
inline void TextEditSpan::clear_length() {
  length_ = 0;
}
inline int32_t TextEditSpan::_internal_length() const {
  return length_;
}
inline int32_t TextEditSpan::length() const {
  // @@protoc_insertion_point(field_get:uif.TextEditSpan.length)
  return _internal_length();
}
inline void TextEditSpan::_internal_set_length(int32_t value) {
  
  length_ = value;
}
inline void TextEditSpan::set_length(int32_t value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:uif.TextEditSpan.length)
}

// string font_name = 4;
inline bool TextEditSpan::_internal_has_font_name() const {
  return edit_case() == kFontName;
}
inline bool TextEditSpan::has_font_name() const {
  return _internal_has_font_name();
}
inline void TextEditSpan::set_has_font_name() {
  _oneof_case_[0] = kFontName;
}
inline void TextEditSpan::clear_font_name() {
  if (_internal_has_font_name()) {
    edit_.font_name_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_edit();
  }
}
inline const std::string& TextEditSpan::font_name() const {
  // @@protoc_insertion_point(field_get:uif.TextEditSpan.font_name)
  return _internal_font_name();
}
template <typename ArgT0, typename... ArgT>
inline void TextEditSpan::set_font_name(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_font_name()) {
    clear_edit();
    set_has_font_name();
    edit_.font_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  edit_.font_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:uif.TextEditSpan.font_name)
}
inline std::string* TextEditSpan::mutable_font_name() {
  std::string* _s = _internal_mutable_font_name();
  // @@protoc_insertion_point(field_mutable:uif.TextEditSpan.font_name)
  return _s;
}
inline const std::string& TextEditSpan::_internal_font_name() const {
  if (_internal_has_font_name()) {
    return edit_.font_name_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void TextEditSpan::_internal_set_font_name(const std::string& value) {
  if (!_internal_has_font_name()) {
    clear_edit();
    set_has_font_name();
    edit_.font_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  edit_.font_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TextEditSpan::_internal_mutable_font_name() {
  if (!_internal_has_font_name()) {
    clear_edit();
    set_has_font_name();
    edit_.font_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return edit_.font_name_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TextEditSpan::release_font_name() {
  // @@protoc_insertion_point(field_release:uif.TextEditSpan.font_name)
  if (_internal_has_font_name()) {
    clear_has_edit();
    return edit_.font_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void TextEditSpan::set_allocated_font_name(std::string* font_name) {
  if (has_edit()) {
    clear_edit();
  }
  if (font_name != nullptr) {
    set_has_font_name();
    edit_.font_name_.UnsafeSetDefault(font_name);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(font_name);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:uif.TextEditSpan.font_name)
}

// .uif.FontWeight font_weight = 5;
inline bool TextEditSpan::_internal_has_font_weight() const {
  return edit_case() == kFontWeight;
}
inline bool TextEditSpan::has_font_weight() const {
  return _internal_has_font_weight();
}
inline void TextEditSpan::set_has_font_weight() {
  _oneof_case_[0] = kFontWeight;
}
inline void TextEditSpan::clear_font_weight() {
  if (_internal_has_font_weight()) {
    edit_.font_weight_ = 0;
    clear_has_edit();
  }
}
inline ::uif::FontWeight TextEditSpan::_internal_font_weight() const {
  if (_internal_has_font_weight()) {
    return static_cast< ::uif::FontWeight >(edit_.font_weight_);
  }
  return static_cast< ::uif::FontWeight >(0);
}
inline ::uif::FontWeight TextEditSpan::font_weight() const {
  // @@protoc_insertion_point(field_get:uif.TextEditSpan.font_weight)
  return _internal_font_weight();
}
inline void TextEditSpan::_internal_set_font_weight(::uif::FontWeight value) {
  if (!_internal_has_font_weight()) {
    clear_edit();
    set_has_font_weight();
  }
  edit_.font_weight_ = value;
}
inline void TextEditSpan::set_font_weight(::uif::FontWeight value) {
  _internal_set_font_weight(value);
  // @@protoc_insertion_point(field_set:uif.TextEditSpan.font_weight)
}

// .uif.FontStyle font_style = 6;
inline bool TextEditSpan::_internal_has_font_style() const {
  return edit_case() == kFontStyle;
}
inline bool TextEditSpan::has_font_style() const {
  return _internal_has_font_style();
}
inline void TextEditSpan::set_has_font_style() {
  _oneof_case_[0] = kFontStyle;
}
inline void TextEditSpan::clear_font_style() {
  if (_internal_has_font_style()) {
    edit_.font_style_ = 0;
    clear_has_edit();
  }
}
inline ::uif::FontStyle TextEditSpan::_internal_font_style() const {
  if (_internal_has_font_style()) {
    return static_cast< ::uif::FontStyle >(edit_.font_style_);
  }
  return static_cast< ::uif::FontStyle >(0);
}
inline ::uif::FontStyle TextEditSpan::font_style() const {
  // @@protoc_insertion_point(field_get:uif.TextEditSpan.font_style)
  return _internal_font_style();
}
inline void TextEditSpan::_internal_set_font_style(::uif::FontStyle value) {
  if (!_internal_has_font_style()) {
    clear_edit();
    set_has_font_style();
  }
  edit_.font_style_ = value;
}
inline void TextEditSpan::set_font_style(::uif::FontStyle value) {
  _internal_set_font_style(value);
  // @@protoc_insertion_point(field_set:uif.TextEditSpan.font_style)
}

// .uif.FontStretch font_stretch = 7;
inline bool TextEditSpan::_internal_has_font_stretch() const {
  return edit_case() == kFontStretch;
}
inline bool TextEditSpan::has_font_stretch() const {
  return _internal_has_font_stretch();
}
inline void TextEditSpan::set_has_font_stretch() {
  _oneof_case_[0] = kFontStretch;
}
inline void TextEditSpan::clear_font_stretch() {
  if (_internal_has_font_stretch()) {
    edit_.font_stretch_ = 0;
    clear_has_edit();
  }
}
inline ::uif::FontStretch TextEditSpan::_internal_font_stretch() const {
  if (_internal_has_font_stretch()) {
    return static_cast< ::uif::FontStretch >(edit_.font_stretch_);
  }
  return static_cast< ::uif::FontStretch >(0);
}
inline ::uif::FontStretch TextEditSpan::font_stretch() const {
  // @@protoc_insertion_point(field_get:uif.TextEditSpan.font_stretch)
  return _internal_font_stretch();
}
inline void TextEditSpan::_internal_set_font_stretch(::uif::FontStretch value) {
  if (!_internal_has_font_stretch()) {
    clear_edit();
    set_has_font_stretch();
  }
  edit_.font_stretch_ = value;
}
inline void TextEditSpan::set_font_stretch(::uif::FontStretch value) {
  _internal_set_font_stretch(value);
  // @@protoc_insertion_point(field_set:uif.TextEditSpan.font_stretch)
}

// float font_size = 8;
inline bool TextEditSpan::_internal_has_font_size() const {
  return edit_case() == kFontSize;
}
inline bool TextEditSpan::has_font_size() const {
  return _internal_has_font_size();
}
inline void TextEditSpan::set_has_font_size() {
  _oneof_case_[0] = kFontSize;
}
inline void TextEditSpan::clear_font_size() {
  if (_internal_has_font_size()) {
    edit_.font_size_ = 0;
    clear_has_edit();
  }
}
inline float TextEditSpan::_internal_font_size() const {
  if (_internal_has_font_size()) {
    return edit_.font_size_;
  }
  return 0;
}
inline void TextEditSpan::_internal_set_font_size(float value) {
  if (!_internal_has_font_size()) {
    clear_edit();
    set_has_font_size();
  }
  edit_.font_size_ = value;
}
inline float TextEditSpan::font_size() const {
  // @@protoc_insertion_point(field_get:uif.TextEditSpan.font_size)
  return _internal_font_size();
}
inline void TextEditSpan::set_font_size(float value) {
  _internal_set_font_size(value);
  // @@protoc_insertion_point(field_set:uif.TextEditSpan.font_size)
}

// .uif.Brush brush = 9;
inline bool TextEditSpan::_internal_has_brush() const {
  return edit_case() == kBrush;
}
inline bool TextEditSpan::has_brush() const {
  return _internal_has_brush();
}
inline void TextEditSpan::set_has_brush() {
  _oneof_case_[0] = kBrush;
}
inline void TextEditSpan::clear_brush() {
  if (_internal_has_brush()) {
    if (GetArenaForAllocation() == nullptr) {
      delete edit_.brush_;
    }
    clear_has_edit();
  }
}
inline ::uif::Brush* TextEditSpan::release_brush() {
  // @@protoc_insertion_point(field_release:uif.TextEditSpan.brush)
  if (_internal_has_brush()) {
    clear_has_edit();
      ::uif::Brush* temp = edit_.brush_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    edit_.brush_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::uif::Brush& TextEditSpan::_internal_brush() const {
  return _internal_has_brush()
      ? *edit_.brush_
      : reinterpret_cast< ::uif::Brush&>(::uif::_Brush_default_instance_);
}
inline const ::uif::Brush& TextEditSpan::brush() const {
  // @@protoc_insertion_point(field_get:uif.TextEditSpan.brush)
  return _internal_brush();
}
inline ::uif::Brush* TextEditSpan::unsafe_arena_release_brush() {
  // @@protoc_insertion_point(field_unsafe_arena_release:uif.TextEditSpan.brush)
  if (_internal_has_brush()) {
    clear_has_edit();
    ::uif::Brush* temp = edit_.brush_;
    edit_.brush_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TextEditSpan::unsafe_arena_set_allocated_brush(::uif::Brush* brush) {
  clear_edit();
  if (brush) {
    set_has_brush();
    edit_.brush_ = brush;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uif.TextEditSpan.brush)
}
inline ::uif::Brush* TextEditSpan::_internal_mutable_brush() {
  if (!_internal_has_brush()) {
    clear_edit();
    set_has_brush();
    edit_.brush_ = CreateMaybeMessage< ::uif::Brush >(GetArenaForAllocation());
  }
  return edit_.brush_;
}
inline ::uif::Brush* TextEditSpan::mutable_brush() {
  ::uif::Brush* _msg = _internal_mutable_brush();
  // @@protoc_insertion_point(field_mutable:uif.TextEditSpan.brush)
  return _msg;
}

// bool underline = 10;
inline bool TextEditSpan::_internal_has_underline() const {
  return edit_case() == kUnderline;
}
inline bool TextEditSpan::has_underline() const {
  return _internal_has_underline();
}
inline void TextEditSpan::set_has_underline() {
  _oneof_case_[0] = kUnderline;
}
inline void TextEditSpan::clear_underline() {
  if (_internal_has_underline()) {
    edit_.underline_ = false;
    clear_has_edit();
  }
}
inline bool TextEditSpan::_internal_underline() const {
  if (_internal_has_underline()) {
    return edit_.underline_;
  }
  return false;
}
inline void TextEditSpan::_internal_set_underline(bool value) {
  if (!_internal_has_underline()) {
    clear_edit();
    set_has_underline();
  }
  edit_.underline_ = value;
}
inline bool TextEditSpan::underline() const {
  // @@protoc_insertion_point(field_get:uif.TextEditSpan.underline)
  return _internal_underline();
}
inline void TextEditSpan::set_underline(bool value) {
  _internal_set_underline(value);
  // @@protoc_insertion_point(field_set:uif.TextEditSpan.underline)
}

inline bool TextEditSpan::has_edit() const {
  return edit_case() != EDIT_NOT_SET;
}
inline void TextEditSpan::clear_has_edit() {
  _oneof_case_[0] = EDIT_NOT_SET;
}
inline TextEditSpan::EditCase TextEditSpan::edit_case() const {
  return TextEditSpan::EditCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TextNode

// .uif.Rectangle bounds = 1;
inline bool TextNode::_internal_has_bounds() const {
  return this != internal_default_instance() && bounds_ != nullptr;
}
inline bool TextNode::has_bounds() const {
  return _internal_has_bounds();
}
inline void TextNode::clear_bounds() {
  if (GetArenaForAllocation() == nullptr && bounds_ != nullptr) {
    delete bounds_;
  }
  bounds_ = nullptr;
}
inline const ::uif::Rectangle& TextNode::_internal_bounds() const {
  const ::uif::Rectangle* p = bounds_;
  return p != nullptr ? *p : reinterpret_cast<const ::uif::Rectangle&>(
      ::uif::_Rectangle_default_instance_);
}
inline const ::uif::Rectangle& TextNode::bounds() const {
  // @@protoc_insertion_point(field_get:uif.TextNode.bounds)
  return _internal_bounds();
}
inline void TextNode::unsafe_arena_set_allocated_bounds(
    ::uif::Rectangle* bounds) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bounds_);
  }
  bounds_ = bounds;
  if (bounds) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uif.TextNode.bounds)
}
inline ::uif::Rectangle* TextNode::release_bounds() {
  
  ::uif::Rectangle* temp = bounds_;
  bounds_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uif::Rectangle* TextNode::unsafe_arena_release_bounds() {
  // @@protoc_insertion_point(field_release:uif.TextNode.bounds)
  
  ::uif::Rectangle* temp = bounds_;
  bounds_ = nullptr;
  return temp;
}
inline ::uif::Rectangle* TextNode::_internal_mutable_bounds() {
  
  if (bounds_ == nullptr) {
    auto* p = CreateMaybeMessage<::uif::Rectangle>(GetArenaForAllocation());
    bounds_ = p;
  }
  return bounds_;
}
inline ::uif::Rectangle* TextNode::mutable_bounds() {
  ::uif::Rectangle* _msg = _internal_mutable_bounds();
  // @@protoc_insertion_point(field_mutable:uif.TextNode.bounds)
  return _msg;
}
inline void TextNode::set_allocated_bounds(::uif::Rectangle* bounds) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete bounds_;
  }
  if (bounds) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::uif::Rectangle>::GetOwningArena(bounds);
    if (message_arena != submessage_arena) {
      bounds = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bounds, submessage_arena);
    }
    
  } else {
    
  }
  bounds_ = bounds;
  // @@protoc_insertion_point(field_set_allocated:uif.TextNode.bounds)
}

// .uif.Brush stroke = 2;
inline bool TextNode::_internal_has_stroke() const {
  return this != internal_default_instance() && stroke_ != nullptr;
}
inline bool TextNode::has_stroke() const {
  return _internal_has_stroke();
}
inline void TextNode::clear_stroke() {
  if (GetArenaForAllocation() == nullptr && stroke_ != nullptr) {
    delete stroke_;
  }
  stroke_ = nullptr;
}
inline const ::uif::Brush& TextNode::_internal_stroke() const {
  const ::uif::Brush* p = stroke_;
  return p != nullptr ? *p : reinterpret_cast<const ::uif::Brush&>(
      ::uif::_Brush_default_instance_);
}
inline const ::uif::Brush& TextNode::stroke() const {
  // @@protoc_insertion_point(field_get:uif.TextNode.stroke)
  return _internal_stroke();
}
inline void TextNode::unsafe_arena_set_allocated_stroke(
    ::uif::Brush* stroke) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stroke_);
  }
  stroke_ = stroke;
  if (stroke) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uif.TextNode.stroke)
}
inline ::uif::Brush* TextNode::release_stroke() {
  
  ::uif::Brush* temp = stroke_;
  stroke_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uif::Brush* TextNode::unsafe_arena_release_stroke() {
  // @@protoc_insertion_point(field_release:uif.TextNode.stroke)
  
  ::uif::Brush* temp = stroke_;
  stroke_ = nullptr;
  return temp;
}
inline ::uif::Brush* TextNode::_internal_mutable_stroke() {
  
  if (stroke_ == nullptr) {
    auto* p = CreateMaybeMessage<::uif::Brush>(GetArenaForAllocation());
    stroke_ = p;
  }
  return stroke_;
}
inline ::uif::Brush* TextNode::mutable_stroke() {
  ::uif::Brush* _msg = _internal_mutable_stroke();
  // @@protoc_insertion_point(field_mutable:uif.TextNode.stroke)
  return _msg;
}
inline void TextNode::set_allocated_stroke(::uif::Brush* stroke) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete stroke_;
  }
  if (stroke) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::uif::Brush>::GetOwningArena(stroke);
    if (message_arena != submessage_arena) {
      stroke = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stroke, submessage_arena);
    }
    
  } else {
    
  }
  stroke_ = stroke;
  // @@protoc_insertion_point(field_set_allocated:uif.TextNode.stroke)
}

// string text = 3;
inline void TextNode::clear_text() {
  text_.ClearToEmpty();
}
inline const std::string& TextNode::text() const {
  // @@protoc_insertion_point(field_get:uif.TextNode.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TextNode::set_text(ArgT0&& arg0, ArgT... args) {
 
 text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:uif.TextNode.text)
}
inline std::string* TextNode::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:uif.TextNode.text)
  return _s;
}
inline const std::string& TextNode::_internal_text() const {
  return text_.Get();
}
inline void TextNode::_internal_set_text(const std::string& value) {
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TextNode::_internal_mutable_text() {
  
  return text_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TextNode::release_text() {
  // @@protoc_insertion_point(field_release:uif.TextNode.text)
  return text_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TextNode::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:uif.TextNode.text)
}

// string font_name = 4;
inline void TextNode::clear_font_name() {
  font_name_.ClearToEmpty();
}
inline const std::string& TextNode::font_name() const {
  // @@protoc_insertion_point(field_get:uif.TextNode.font_name)
  return _internal_font_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TextNode::set_font_name(ArgT0&& arg0, ArgT... args) {
 
 font_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:uif.TextNode.font_name)
}
inline std::string* TextNode::mutable_font_name() {
  std::string* _s = _internal_mutable_font_name();
  // @@protoc_insertion_point(field_mutable:uif.TextNode.font_name)
  return _s;
}
inline const std::string& TextNode::_internal_font_name() const {
  return font_name_.Get();
}
inline void TextNode::_internal_set_font_name(const std::string& value) {
  
  font_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TextNode::_internal_mutable_font_name() {
  
  return font_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TextNode::release_font_name() {
  // @@protoc_insertion_point(field_release:uif.TextNode.font_name)
  return font_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TextNode::set_allocated_font_name(std::string* font_name) {
  if (font_name != nullptr) {
    
  } else {
    
  }
  font_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), font_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (font_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    font_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:uif.TextNode.font_name)
}

// .uif.FontWeight font_weight = 5;
inline void TextNode::clear_font_weight() {
  font_weight_ = 0;
}
inline ::uif::FontWeight TextNode::_internal_font_weight() const {
  return static_cast< ::uif::FontWeight >(font_weight_);
}
inline ::uif::FontWeight TextNode::font_weight() const {
  // @@protoc_insertion_point(field_get:uif.TextNode.font_weight)
  return _internal_font_weight();
}
inline void TextNode::_internal_set_font_weight(::uif::FontWeight value) {
  
  font_weight_ = value;
}
inline void TextNode::set_font_weight(::uif::FontWeight value) {
  _internal_set_font_weight(value);
  // @@protoc_insertion_point(field_set:uif.TextNode.font_weight)
}

// .uif.FontStyle font_style = 6;
inline void TextNode::clear_font_style() {
  font_style_ = 0;
}
inline ::uif::FontStyle TextNode::_internal_font_style() const {
  return static_cast< ::uif::FontStyle >(font_style_);
}
inline ::uif::FontStyle TextNode::font_style() const {
  // @@protoc_insertion_point(field_get:uif.TextNode.font_style)
  return _internal_font_style();
}
inline void TextNode::_internal_set_font_style(::uif::FontStyle value) {
  
  font_style_ = value;
}
inline void TextNode::set_font_style(::uif::FontStyle value) {
  _internal_set_font_style(value);
  // @@protoc_insertion_point(field_set:uif.TextNode.font_style)
}

// .uif.FontStretch font_stretch = 7;
inline void TextNode::clear_font_stretch() {
  font_stretch_ = 0;
}
inline ::uif::FontStretch TextNode::_internal_font_stretch() const {
  return static_cast< ::uif::FontStretch >(font_stretch_);
}
inline ::uif::FontStretch TextNode::font_stretch() const {
  // @@protoc_insertion_point(field_get:uif.TextNode.font_stretch)
  return _internal_font_stretch();
}
inline void TextNode::_internal_set_font_stretch(::uif::FontStretch value) {
  
  font_stretch_ = value;
}
inline void TextNode::set_font_stretch(::uif::FontStretch value) {
  _internal_set_font_stretch(value);
  // @@protoc_insertion_point(field_set:uif.TextNode.font_stretch)
}

// float font_size = 8;
inline void TextNode::clear_font_size() {
  font_size_ = 0;
}
inline float TextNode::_internal_font_size() const {
  return font_size_;
}
inline float TextNode::font_size() const {
  // @@protoc_insertion_point(field_get:uif.TextNode.font_size)
  return _internal_font_size();
}
inline void TextNode::_internal_set_font_size(float value) {
  
  font_size_ = value;
}
inline void TextNode::set_font_size(float value) {
  _internal_set_font_size(value);
  // @@protoc_insertion_point(field_set:uif.TextNode.font_size)
}

// .uif.TextAlign text_align = 9;
inline void TextNode::clear_text_align() {
  text_align_ = 0;
}
inline ::uif::TextAlign TextNode::_internal_text_align() const {
  return static_cast< ::uif::TextAlign >(text_align_);
}
inline ::uif::TextAlign TextNode::text_align() const {
  // @@protoc_insertion_point(field_get:uif.TextNode.text_align)
  return _internal_text_align();
}
inline void TextNode::_internal_set_text_align(::uif::TextAlign value) {
  
  text_align_ = value;
}
inline void TextNode::set_text_align(::uif::TextAlign value) {
  _internal_set_text_align(value);
  // @@protoc_insertion_point(field_set:uif.TextNode.text_align)
}

// .uif.ParagraphAlign paragraph_align = 10;
inline void TextNode::clear_paragraph_align() {
  paragraph_align_ = 0;
}
inline ::uif::ParagraphAlign TextNode::_internal_paragraph_align() const {
  return static_cast< ::uif::ParagraphAlign >(paragraph_align_);
}
inline ::uif::ParagraphAlign TextNode::paragraph_align() const {
  // @@protoc_insertion_point(field_get:uif.TextNode.paragraph_align)
  return _internal_paragraph_align();
}
inline void TextNode::_internal_set_paragraph_align(::uif::ParagraphAlign value) {
  
  paragraph_align_ = value;
}
inline void TextNode::set_paragraph_align(::uif::ParagraphAlign value) {
  _internal_set_paragraph_align(value);
  // @@protoc_insertion_point(field_set:uif.TextNode.paragraph_align)
}

// repeated .uif.TextEditSpan edit_spans = 11;
inline int TextNode::_internal_edit_spans_size() const {
  return edit_spans_.size();
}
inline int TextNode::edit_spans_size() const {
  return _internal_edit_spans_size();
}
inline void TextNode::clear_edit_spans() {
  edit_spans_.Clear();
}
inline ::uif::TextEditSpan* TextNode::mutable_edit_spans(int index) {
  // @@protoc_insertion_point(field_mutable:uif.TextNode.edit_spans)
  return edit_spans_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::uif::TextEditSpan >*
TextNode::mutable_edit_spans() {
  // @@protoc_insertion_point(field_mutable_list:uif.TextNode.edit_spans)
  return &edit_spans_;
}
inline const ::uif::TextEditSpan& TextNode::_internal_edit_spans(int index) const {
  return edit_spans_.Get(index);
}
inline const ::uif::TextEditSpan& TextNode::edit_spans(int index) const {
  // @@protoc_insertion_point(field_get:uif.TextNode.edit_spans)
  return _internal_edit_spans(index);
}
inline ::uif::TextEditSpan* TextNode::_internal_add_edit_spans() {
  return edit_spans_.Add();
}
inline ::uif::TextEditSpan* TextNode::add_edit_spans() {
  ::uif::TextEditSpan* _add = _internal_add_edit_spans();
  // @@protoc_insertion_point(field_add:uif.TextNode.edit_spans)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::uif::TextEditSpan >&
TextNode::edit_spans() const {
  // @@protoc_insertion_point(field_list:uif.TextNode.edit_spans)
  return edit_spans_;
}

// -------------------------------------------------------------------

// PCBegin

// .uif.PCBeginKind kind = 1;
inline void PCBegin::clear_kind() {
  kind_ = 0;
}
inline ::uif::PCBeginKind PCBegin::_internal_kind() const {
  return static_cast< ::uif::PCBeginKind >(kind_);
}
inline ::uif::PCBeginKind PCBegin::kind() const {
  // @@protoc_insertion_point(field_get:uif.PCBegin.kind)
  return _internal_kind();
}
inline void PCBegin::_internal_set_kind(::uif::PCBeginKind value) {
  
  kind_ = value;
}
inline void PCBegin::set_kind(::uif::PCBeginKind value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:uif.PCBegin.kind)
}

// .uif.Point pt = 2;
inline bool PCBegin::_internal_has_pt() const {
  return this != internal_default_instance() && pt_ != nullptr;
}
inline bool PCBegin::has_pt() const {
  return _internal_has_pt();
}
inline void PCBegin::clear_pt() {
  if (GetArenaForAllocation() == nullptr && pt_ != nullptr) {
    delete pt_;
  }
  pt_ = nullptr;
}
inline const ::uif::Point& PCBegin::_internal_pt() const {
  const ::uif::Point* p = pt_;
  return p != nullptr ? *p : reinterpret_cast<const ::uif::Point&>(
      ::uif::_Point_default_instance_);
}
inline const ::uif::Point& PCBegin::pt() const {
  // @@protoc_insertion_point(field_get:uif.PCBegin.pt)
  return _internal_pt();
}
inline void PCBegin::unsafe_arena_set_allocated_pt(
    ::uif::Point* pt) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pt_);
  }
  pt_ = pt;
  if (pt) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uif.PCBegin.pt)
}
inline ::uif::Point* PCBegin::release_pt() {
  
  ::uif::Point* temp = pt_;
  pt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uif::Point* PCBegin::unsafe_arena_release_pt() {
  // @@protoc_insertion_point(field_release:uif.PCBegin.pt)
  
  ::uif::Point* temp = pt_;
  pt_ = nullptr;
  return temp;
}
inline ::uif::Point* PCBegin::_internal_mutable_pt() {
  
  if (pt_ == nullptr) {
    auto* p = CreateMaybeMessage<::uif::Point>(GetArenaForAllocation());
    pt_ = p;
  }
  return pt_;
}
inline ::uif::Point* PCBegin::mutable_pt() {
  ::uif::Point* _msg = _internal_mutable_pt();
  // @@protoc_insertion_point(field_mutable:uif.PCBegin.pt)
  return _msg;
}
inline void PCBegin::set_allocated_pt(::uif::Point* pt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete pt_;
  }
  if (pt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::uif::Point>::GetOwningArena(pt);
    if (message_arena != submessage_arena) {
      pt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pt, submessage_arena);
    }
    
  } else {
    
  }
  pt_ = pt;
  // @@protoc_insertion_point(field_set_allocated:uif.PCBegin.pt)
}

// -------------------------------------------------------------------

// PCEnd

// .uif.PCEndKind kind = 1;
inline void PCEnd::clear_kind() {
  kind_ = 0;
}
inline ::uif::PCEndKind PCEnd::_internal_kind() const {
  return static_cast< ::uif::PCEndKind >(kind_);
}
inline ::uif::PCEndKind PCEnd::kind() const {
  // @@protoc_insertion_point(field_get:uif.PCEnd.kind)
  return _internal_kind();
}
inline void PCEnd::_internal_set_kind(::uif::PCEndKind value) {
  
  kind_ = value;
}
inline void PCEnd::set_kind(::uif::PCEndKind value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:uif.PCEnd.kind)
}

// -------------------------------------------------------------------

// PCLineTo

// .uif.Point pt = 1;
inline bool PCLineTo::_internal_has_pt() const {
  return this != internal_default_instance() && pt_ != nullptr;
}
inline bool PCLineTo::has_pt() const {
  return _internal_has_pt();
}
inline void PCLineTo::clear_pt() {
  if (GetArenaForAllocation() == nullptr && pt_ != nullptr) {
    delete pt_;
  }
  pt_ = nullptr;
}
inline const ::uif::Point& PCLineTo::_internal_pt() const {
  const ::uif::Point* p = pt_;
  return p != nullptr ? *p : reinterpret_cast<const ::uif::Point&>(
      ::uif::_Point_default_instance_);
}
inline const ::uif::Point& PCLineTo::pt() const {
  // @@protoc_insertion_point(field_get:uif.PCLineTo.pt)
  return _internal_pt();
}
inline void PCLineTo::unsafe_arena_set_allocated_pt(
    ::uif::Point* pt) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pt_);
  }
  pt_ = pt;
  if (pt) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uif.PCLineTo.pt)
}
inline ::uif::Point* PCLineTo::release_pt() {
  
  ::uif::Point* temp = pt_;
  pt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uif::Point* PCLineTo::unsafe_arena_release_pt() {
  // @@protoc_insertion_point(field_release:uif.PCLineTo.pt)
  
  ::uif::Point* temp = pt_;
  pt_ = nullptr;
  return temp;
}
inline ::uif::Point* PCLineTo::_internal_mutable_pt() {
  
  if (pt_ == nullptr) {
    auto* p = CreateMaybeMessage<::uif::Point>(GetArenaForAllocation());
    pt_ = p;
  }
  return pt_;
}
inline ::uif::Point* PCLineTo::mutable_pt() {
  ::uif::Point* _msg = _internal_mutable_pt();
  // @@protoc_insertion_point(field_mutable:uif.PCLineTo.pt)
  return _msg;
}
inline void PCLineTo::set_allocated_pt(::uif::Point* pt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete pt_;
  }
  if (pt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::uif::Point>::GetOwningArena(pt);
    if (message_arena != submessage_arena) {
      pt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pt, submessage_arena);
    }
    
  } else {
    
  }
  pt_ = pt;
  // @@protoc_insertion_point(field_set_allocated:uif.PCLineTo.pt)
}

// -------------------------------------------------------------------

// PCCubicCurve

// .uif.Point control1 = 1;
inline bool PCCubicCurve::_internal_has_control1() const {
  return this != internal_default_instance() && control1_ != nullptr;
}
inline bool PCCubicCurve::has_control1() const {
  return _internal_has_control1();
}
inline void PCCubicCurve::clear_control1() {
  if (GetArenaForAllocation() == nullptr && control1_ != nullptr) {
    delete control1_;
  }
  control1_ = nullptr;
}
inline const ::uif::Point& PCCubicCurve::_internal_control1() const {
  const ::uif::Point* p = control1_;
  return p != nullptr ? *p : reinterpret_cast<const ::uif::Point&>(
      ::uif::_Point_default_instance_);
}
inline const ::uif::Point& PCCubicCurve::control1() const {
  // @@protoc_insertion_point(field_get:uif.PCCubicCurve.control1)
  return _internal_control1();
}
inline void PCCubicCurve::unsafe_arena_set_allocated_control1(
    ::uif::Point* control1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(control1_);
  }
  control1_ = control1;
  if (control1) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uif.PCCubicCurve.control1)
}
inline ::uif::Point* PCCubicCurve::release_control1() {
  
  ::uif::Point* temp = control1_;
  control1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uif::Point* PCCubicCurve::unsafe_arena_release_control1() {
  // @@protoc_insertion_point(field_release:uif.PCCubicCurve.control1)
  
  ::uif::Point* temp = control1_;
  control1_ = nullptr;
  return temp;
}
inline ::uif::Point* PCCubicCurve::_internal_mutable_control1() {
  
  if (control1_ == nullptr) {
    auto* p = CreateMaybeMessage<::uif::Point>(GetArenaForAllocation());
    control1_ = p;
  }
  return control1_;
}
inline ::uif::Point* PCCubicCurve::mutable_control1() {
  ::uif::Point* _msg = _internal_mutable_control1();
  // @@protoc_insertion_point(field_mutable:uif.PCCubicCurve.control1)
  return _msg;
}
inline void PCCubicCurve::set_allocated_control1(::uif::Point* control1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete control1_;
  }
  if (control1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::uif::Point>::GetOwningArena(control1);
    if (message_arena != submessage_arena) {
      control1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, control1, submessage_arena);
    }
    
  } else {
    
  }
  control1_ = control1;
  // @@protoc_insertion_point(field_set_allocated:uif.PCCubicCurve.control1)
}

// .uif.Point control2 = 2;
inline bool PCCubicCurve::_internal_has_control2() const {
  return this != internal_default_instance() && control2_ != nullptr;
}
inline bool PCCubicCurve::has_control2() const {
  return _internal_has_control2();
}
inline void PCCubicCurve::clear_control2() {
  if (GetArenaForAllocation() == nullptr && control2_ != nullptr) {
    delete control2_;
  }
  control2_ = nullptr;
}
inline const ::uif::Point& PCCubicCurve::_internal_control2() const {
  const ::uif::Point* p = control2_;
  return p != nullptr ? *p : reinterpret_cast<const ::uif::Point&>(
      ::uif::_Point_default_instance_);
}
inline const ::uif::Point& PCCubicCurve::control2() const {
  // @@protoc_insertion_point(field_get:uif.PCCubicCurve.control2)
  return _internal_control2();
}
inline void PCCubicCurve::unsafe_arena_set_allocated_control2(
    ::uif::Point* control2) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(control2_);
  }
  control2_ = control2;
  if (control2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uif.PCCubicCurve.control2)
}
inline ::uif::Point* PCCubicCurve::release_control2() {
  
  ::uif::Point* temp = control2_;
  control2_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uif::Point* PCCubicCurve::unsafe_arena_release_control2() {
  // @@protoc_insertion_point(field_release:uif.PCCubicCurve.control2)
  
  ::uif::Point* temp = control2_;
  control2_ = nullptr;
  return temp;
}
inline ::uif::Point* PCCubicCurve::_internal_mutable_control2() {
  
  if (control2_ == nullptr) {
    auto* p = CreateMaybeMessage<::uif::Point>(GetArenaForAllocation());
    control2_ = p;
  }
  return control2_;
}
inline ::uif::Point* PCCubicCurve::mutable_control2() {
  ::uif::Point* _msg = _internal_mutable_control2();
  // @@protoc_insertion_point(field_mutable:uif.PCCubicCurve.control2)
  return _msg;
}
inline void PCCubicCurve::set_allocated_control2(::uif::Point* control2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete control2_;
  }
  if (control2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::uif::Point>::GetOwningArena(control2);
    if (message_arena != submessage_arena) {
      control2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, control2, submessage_arena);
    }
    
  } else {
    
  }
  control2_ = control2;
  // @@protoc_insertion_point(field_set_allocated:uif.PCCubicCurve.control2)
}

// .uif.Point end = 3;
inline bool PCCubicCurve::_internal_has_end() const {
  return this != internal_default_instance() && end_ != nullptr;
}
inline bool PCCubicCurve::has_end() const {
  return _internal_has_end();
}
inline void PCCubicCurve::clear_end() {
  if (GetArenaForAllocation() == nullptr && end_ != nullptr) {
    delete end_;
  }
  end_ = nullptr;
}
inline const ::uif::Point& PCCubicCurve::_internal_end() const {
  const ::uif::Point* p = end_;
  return p != nullptr ? *p : reinterpret_cast<const ::uif::Point&>(
      ::uif::_Point_default_instance_);
}
inline const ::uif::Point& PCCubicCurve::end() const {
  // @@protoc_insertion_point(field_get:uif.PCCubicCurve.end)
  return _internal_end();
}
inline void PCCubicCurve::unsafe_arena_set_allocated_end(
    ::uif::Point* end) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_);
  }
  end_ = end;
  if (end) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uif.PCCubicCurve.end)
}
inline ::uif::Point* PCCubicCurve::release_end() {
  
  ::uif::Point* temp = end_;
  end_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uif::Point* PCCubicCurve::unsafe_arena_release_end() {
  // @@protoc_insertion_point(field_release:uif.PCCubicCurve.end)
  
  ::uif::Point* temp = end_;
  end_ = nullptr;
  return temp;
}
inline ::uif::Point* PCCubicCurve::_internal_mutable_end() {
  
  if (end_ == nullptr) {
    auto* p = CreateMaybeMessage<::uif::Point>(GetArenaForAllocation());
    end_ = p;
  }
  return end_;
}
inline ::uif::Point* PCCubicCurve::mutable_end() {
  ::uif::Point* _msg = _internal_mutable_end();
  // @@protoc_insertion_point(field_mutable:uif.PCCubicCurve.end)
  return _msg;
}
inline void PCCubicCurve::set_allocated_end(::uif::Point* end) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete end_;
  }
  if (end) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::uif::Point>::GetOwningArena(end);
    if (message_arena != submessage_arena) {
      end = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end, submessage_arena);
    }
    
  } else {
    
  }
  end_ = end;
  // @@protoc_insertion_point(field_set_allocated:uif.PCCubicCurve.end)
}

// -------------------------------------------------------------------

// PCQuadraticCurve

// .uif.Point control1 = 1;
inline bool PCQuadraticCurve::_internal_has_control1() const {
  return this != internal_default_instance() && control1_ != nullptr;
}
inline bool PCQuadraticCurve::has_control1() const {
  return _internal_has_control1();
}
inline void PCQuadraticCurve::clear_control1() {
  if (GetArenaForAllocation() == nullptr && control1_ != nullptr) {
    delete control1_;
  }
  control1_ = nullptr;
}
inline const ::uif::Point& PCQuadraticCurve::_internal_control1() const {
  const ::uif::Point* p = control1_;
  return p != nullptr ? *p : reinterpret_cast<const ::uif::Point&>(
      ::uif::_Point_default_instance_);
}
inline const ::uif::Point& PCQuadraticCurve::control1() const {
  // @@protoc_insertion_point(field_get:uif.PCQuadraticCurve.control1)
  return _internal_control1();
}
inline void PCQuadraticCurve::unsafe_arena_set_allocated_control1(
    ::uif::Point* control1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(control1_);
  }
  control1_ = control1;
  if (control1) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uif.PCQuadraticCurve.control1)
}
inline ::uif::Point* PCQuadraticCurve::release_control1() {
  
  ::uif::Point* temp = control1_;
  control1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uif::Point* PCQuadraticCurve::unsafe_arena_release_control1() {
  // @@protoc_insertion_point(field_release:uif.PCQuadraticCurve.control1)
  
  ::uif::Point* temp = control1_;
  control1_ = nullptr;
  return temp;
}
inline ::uif::Point* PCQuadraticCurve::_internal_mutable_control1() {
  
  if (control1_ == nullptr) {
    auto* p = CreateMaybeMessage<::uif::Point>(GetArenaForAllocation());
    control1_ = p;
  }
  return control1_;
}
inline ::uif::Point* PCQuadraticCurve::mutable_control1() {
  ::uif::Point* _msg = _internal_mutable_control1();
  // @@protoc_insertion_point(field_mutable:uif.PCQuadraticCurve.control1)
  return _msg;
}
inline void PCQuadraticCurve::set_allocated_control1(::uif::Point* control1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete control1_;
  }
  if (control1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::uif::Point>::GetOwningArena(control1);
    if (message_arena != submessage_arena) {
      control1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, control1, submessage_arena);
    }
    
  } else {
    
  }
  control1_ = control1;
  // @@protoc_insertion_point(field_set_allocated:uif.PCQuadraticCurve.control1)
}

// .uif.Point end = 2;
inline bool PCQuadraticCurve::_internal_has_end() const {
  return this != internal_default_instance() && end_ != nullptr;
}
inline bool PCQuadraticCurve::has_end() const {
  return _internal_has_end();
}
inline void PCQuadraticCurve::clear_end() {
  if (GetArenaForAllocation() == nullptr && end_ != nullptr) {
    delete end_;
  }
  end_ = nullptr;
}
inline const ::uif::Point& PCQuadraticCurve::_internal_end() const {
  const ::uif::Point* p = end_;
  return p != nullptr ? *p : reinterpret_cast<const ::uif::Point&>(
      ::uif::_Point_default_instance_);
}
inline const ::uif::Point& PCQuadraticCurve::end() const {
  // @@protoc_insertion_point(field_get:uif.PCQuadraticCurve.end)
  return _internal_end();
}
inline void PCQuadraticCurve::unsafe_arena_set_allocated_end(
    ::uif::Point* end) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_);
  }
  end_ = end;
  if (end) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uif.PCQuadraticCurve.end)
}
inline ::uif::Point* PCQuadraticCurve::release_end() {
  
  ::uif::Point* temp = end_;
  end_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uif::Point* PCQuadraticCurve::unsafe_arena_release_end() {
  // @@protoc_insertion_point(field_release:uif.PCQuadraticCurve.end)
  
  ::uif::Point* temp = end_;
  end_ = nullptr;
  return temp;
}
inline ::uif::Point* PCQuadraticCurve::_internal_mutable_end() {
  
  if (end_ == nullptr) {
    auto* p = CreateMaybeMessage<::uif::Point>(GetArenaForAllocation());
    end_ = p;
  }
  return end_;
}
inline ::uif::Point* PCQuadraticCurve::mutable_end() {
  ::uif::Point* _msg = _internal_mutable_end();
  // @@protoc_insertion_point(field_mutable:uif.PCQuadraticCurve.end)
  return _msg;
}
inline void PCQuadraticCurve::set_allocated_end(::uif::Point* end) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete end_;
  }
  if (end) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::uif::Point>::GetOwningArena(end);
    if (message_arena != submessage_arena) {
      end = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end, submessage_arena);
    }
    
  } else {
    
  }
  end_ = end;
  // @@protoc_insertion_point(field_set_allocated:uif.PCQuadraticCurve.end)
}

// -------------------------------------------------------------------

// PCArc

// float x_radius = 1;
inline void PCArc::clear_x_radius() {
  x_radius_ = 0;
}
inline float PCArc::_internal_x_radius() const {
  return x_radius_;
}
inline float PCArc::x_radius() const {
  // @@protoc_insertion_point(field_get:uif.PCArc.x_radius)
  return _internal_x_radius();
}
inline void PCArc::_internal_set_x_radius(float value) {
  
  x_radius_ = value;
}
inline void PCArc::set_x_radius(float value) {
  _internal_set_x_radius(value);
  // @@protoc_insertion_point(field_set:uif.PCArc.x_radius)
}

// float y_radius = 2;
inline void PCArc::clear_y_radius() {
  y_radius_ = 0;
}
inline float PCArc::_internal_y_radius() const {
  return y_radius_;
}
inline float PCArc::y_radius() const {
  // @@protoc_insertion_point(field_get:uif.PCArc.y_radius)
  return _internal_y_radius();
}
inline void PCArc::_internal_set_y_radius(float value) {
  
  y_radius_ = value;
}
inline void PCArc::set_y_radius(float value) {
  _internal_set_y_radius(value);
  // @@protoc_insertion_point(field_set:uif.PCArc.y_radius)
}

// float x_axis_rotation = 3;
inline void PCArc::clear_x_axis_rotation() {
  x_axis_rotation_ = 0;
}
inline float PCArc::_internal_x_axis_rotation() const {
  return x_axis_rotation_;
}
inline float PCArc::x_axis_rotation() const {
  // @@protoc_insertion_point(field_get:uif.PCArc.x_axis_rotation)
  return _internal_x_axis_rotation();
}
inline void PCArc::_internal_set_x_axis_rotation(float value) {
  
  x_axis_rotation_ = value;
}
inline void PCArc::set_x_axis_rotation(float value) {
  _internal_set_x_axis_rotation(value);
  // @@protoc_insertion_point(field_set:uif.PCArc.x_axis_rotation)
}

// bool large_arc_flag = 4;
inline void PCArc::clear_large_arc_flag() {
  large_arc_flag_ = false;
}
inline bool PCArc::_internal_large_arc_flag() const {
  return large_arc_flag_;
}
inline bool PCArc::large_arc_flag() const {
  // @@protoc_insertion_point(field_get:uif.PCArc.large_arc_flag)
  return _internal_large_arc_flag();
}
inline void PCArc::_internal_set_large_arc_flag(bool value) {
  
  large_arc_flag_ = value;
}
inline void PCArc::set_large_arc_flag(bool value) {
  _internal_set_large_arc_flag(value);
  // @@protoc_insertion_point(field_set:uif.PCArc.large_arc_flag)
}

// bool sweep_flag = 5;
inline void PCArc::clear_sweep_flag() {
  sweep_flag_ = false;
}
inline bool PCArc::_internal_sweep_flag() const {
  return sweep_flag_;
}
inline bool PCArc::sweep_flag() const {
  // @@protoc_insertion_point(field_get:uif.PCArc.sweep_flag)
  return _internal_sweep_flag();
}
inline void PCArc::_internal_set_sweep_flag(bool value) {
  
  sweep_flag_ = value;
}
inline void PCArc::set_sweep_flag(bool value) {
  _internal_set_sweep_flag(value);
  // @@protoc_insertion_point(field_set:uif.PCArc.sweep_flag)
}

// .uif.Point end = 6;
inline bool PCArc::_internal_has_end() const {
  return this != internal_default_instance() && end_ != nullptr;
}
inline bool PCArc::has_end() const {
  return _internal_has_end();
}
inline void PCArc::clear_end() {
  if (GetArenaForAllocation() == nullptr && end_ != nullptr) {
    delete end_;
  }
  end_ = nullptr;
}
inline const ::uif::Point& PCArc::_internal_end() const {
  const ::uif::Point* p = end_;
  return p != nullptr ? *p : reinterpret_cast<const ::uif::Point&>(
      ::uif::_Point_default_instance_);
}
inline const ::uif::Point& PCArc::end() const {
  // @@protoc_insertion_point(field_get:uif.PCArc.end)
  return _internal_end();
}
inline void PCArc::unsafe_arena_set_allocated_end(
    ::uif::Point* end) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_);
  }
  end_ = end;
  if (end) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uif.PCArc.end)
}
inline ::uif::Point* PCArc::release_end() {
  
  ::uif::Point* temp = end_;
  end_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uif::Point* PCArc::unsafe_arena_release_end() {
  // @@protoc_insertion_point(field_release:uif.PCArc.end)
  
  ::uif::Point* temp = end_;
  end_ = nullptr;
  return temp;
}
inline ::uif::Point* PCArc::_internal_mutable_end() {
  
  if (end_ == nullptr) {
    auto* p = CreateMaybeMessage<::uif::Point>(GetArenaForAllocation());
    end_ = p;
  }
  return end_;
}
inline ::uif::Point* PCArc::mutable_end() {
  ::uif::Point* _msg = _internal_mutable_end();
  // @@protoc_insertion_point(field_mutable:uif.PCArc.end)
  return _msg;
}
inline void PCArc::set_allocated_end(::uif::Point* end) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete end_;
  }
  if (end) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::uif::Point>::GetOwningArena(end);
    if (message_arena != submessage_arena) {
      end = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end, submessage_arena);
    }
    
  } else {
    
  }
  end_ = end;
  // @@protoc_insertion_point(field_set_allocated:uif.PCArc.end)
}

// -------------------------------------------------------------------

// PathCommand

// .uif.PCBegin begin = 10;
inline bool PathCommand::_internal_has_begin() const {
  return cmd_case() == kBegin;
}
inline bool PathCommand::has_begin() const {
  return _internal_has_begin();
}
inline void PathCommand::set_has_begin() {
  _oneof_case_[0] = kBegin;
}
inline void PathCommand::clear_begin() {
  if (_internal_has_begin()) {
    if (GetArenaForAllocation() == nullptr) {
      delete cmd_.begin_;
    }
    clear_has_cmd();
  }
}
inline ::uif::PCBegin* PathCommand::release_begin() {
  // @@protoc_insertion_point(field_release:uif.PathCommand.begin)
  if (_internal_has_begin()) {
    clear_has_cmd();
      ::uif::PCBegin* temp = cmd_.begin_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    cmd_.begin_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::uif::PCBegin& PathCommand::_internal_begin() const {
  return _internal_has_begin()
      ? *cmd_.begin_
      : reinterpret_cast< ::uif::PCBegin&>(::uif::_PCBegin_default_instance_);
}
inline const ::uif::PCBegin& PathCommand::begin() const {
  // @@protoc_insertion_point(field_get:uif.PathCommand.begin)
  return _internal_begin();
}
inline ::uif::PCBegin* PathCommand::unsafe_arena_release_begin() {
  // @@protoc_insertion_point(field_unsafe_arena_release:uif.PathCommand.begin)
  if (_internal_has_begin()) {
    clear_has_cmd();
    ::uif::PCBegin* temp = cmd_.begin_;
    cmd_.begin_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PathCommand::unsafe_arena_set_allocated_begin(::uif::PCBegin* begin) {
  clear_cmd();
  if (begin) {
    set_has_begin();
    cmd_.begin_ = begin;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uif.PathCommand.begin)
}
inline ::uif::PCBegin* PathCommand::_internal_mutable_begin() {
  if (!_internal_has_begin()) {
    clear_cmd();
    set_has_begin();
    cmd_.begin_ = CreateMaybeMessage< ::uif::PCBegin >(GetArenaForAllocation());
  }
  return cmd_.begin_;
}
inline ::uif::PCBegin* PathCommand::mutable_begin() {
  ::uif::PCBegin* _msg = _internal_mutable_begin();
  // @@protoc_insertion_point(field_mutable:uif.PathCommand.begin)
  return _msg;
}

// .uif.PCEnd end = 20;
inline bool PathCommand::_internal_has_end() const {
  return cmd_case() == kEnd;
}
inline bool PathCommand::has_end() const {
  return _internal_has_end();
}
inline void PathCommand::set_has_end() {
  _oneof_case_[0] = kEnd;
}
inline void PathCommand::clear_end() {
  if (_internal_has_end()) {
    if (GetArenaForAllocation() == nullptr) {
      delete cmd_.end_;
    }
    clear_has_cmd();
  }
}
inline ::uif::PCEnd* PathCommand::release_end() {
  // @@protoc_insertion_point(field_release:uif.PathCommand.end)
  if (_internal_has_end()) {
    clear_has_cmd();
      ::uif::PCEnd* temp = cmd_.end_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    cmd_.end_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::uif::PCEnd& PathCommand::_internal_end() const {
  return _internal_has_end()
      ? *cmd_.end_
      : reinterpret_cast< ::uif::PCEnd&>(::uif::_PCEnd_default_instance_);
}
inline const ::uif::PCEnd& PathCommand::end() const {
  // @@protoc_insertion_point(field_get:uif.PathCommand.end)
  return _internal_end();
}
inline ::uif::PCEnd* PathCommand::unsafe_arena_release_end() {
  // @@protoc_insertion_point(field_unsafe_arena_release:uif.PathCommand.end)
  if (_internal_has_end()) {
    clear_has_cmd();
    ::uif::PCEnd* temp = cmd_.end_;
    cmd_.end_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PathCommand::unsafe_arena_set_allocated_end(::uif::PCEnd* end) {
  clear_cmd();
  if (end) {
    set_has_end();
    cmd_.end_ = end;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uif.PathCommand.end)
}
inline ::uif::PCEnd* PathCommand::_internal_mutable_end() {
  if (!_internal_has_end()) {
    clear_cmd();
    set_has_end();
    cmd_.end_ = CreateMaybeMessage< ::uif::PCEnd >(GetArenaForAllocation());
  }
  return cmd_.end_;
}
inline ::uif::PCEnd* PathCommand::mutable_end() {
  ::uif::PCEnd* _msg = _internal_mutable_end();
  // @@protoc_insertion_point(field_mutable:uif.PathCommand.end)
  return _msg;
}

// .uif.PCLineTo line_to = 11;
inline bool PathCommand::_internal_has_line_to() const {
  return cmd_case() == kLineTo;
}
inline bool PathCommand::has_line_to() const {
  return _internal_has_line_to();
}
inline void PathCommand::set_has_line_to() {
  _oneof_case_[0] = kLineTo;
}
inline void PathCommand::clear_line_to() {
  if (_internal_has_line_to()) {
    if (GetArenaForAllocation() == nullptr) {
      delete cmd_.line_to_;
    }
    clear_has_cmd();
  }
}
inline ::uif::PCLineTo* PathCommand::release_line_to() {
  // @@protoc_insertion_point(field_release:uif.PathCommand.line_to)
  if (_internal_has_line_to()) {
    clear_has_cmd();
      ::uif::PCLineTo* temp = cmd_.line_to_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    cmd_.line_to_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::uif::PCLineTo& PathCommand::_internal_line_to() const {
  return _internal_has_line_to()
      ? *cmd_.line_to_
      : reinterpret_cast< ::uif::PCLineTo&>(::uif::_PCLineTo_default_instance_);
}
inline const ::uif::PCLineTo& PathCommand::line_to() const {
  // @@protoc_insertion_point(field_get:uif.PathCommand.line_to)
  return _internal_line_to();
}
inline ::uif::PCLineTo* PathCommand::unsafe_arena_release_line_to() {
  // @@protoc_insertion_point(field_unsafe_arena_release:uif.PathCommand.line_to)
  if (_internal_has_line_to()) {
    clear_has_cmd();
    ::uif::PCLineTo* temp = cmd_.line_to_;
    cmd_.line_to_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PathCommand::unsafe_arena_set_allocated_line_to(::uif::PCLineTo* line_to) {
  clear_cmd();
  if (line_to) {
    set_has_line_to();
    cmd_.line_to_ = line_to;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uif.PathCommand.line_to)
}
inline ::uif::PCLineTo* PathCommand::_internal_mutable_line_to() {
  if (!_internal_has_line_to()) {
    clear_cmd();
    set_has_line_to();
    cmd_.line_to_ = CreateMaybeMessage< ::uif::PCLineTo >(GetArenaForAllocation());
  }
  return cmd_.line_to_;
}
inline ::uif::PCLineTo* PathCommand::mutable_line_to() {
  ::uif::PCLineTo* _msg = _internal_mutable_line_to();
  // @@protoc_insertion_point(field_mutable:uif.PathCommand.line_to)
  return _msg;
}

// .uif.PCCubicCurve cubic_to = 12;
inline bool PathCommand::_internal_has_cubic_to() const {
  return cmd_case() == kCubicTo;
}
inline bool PathCommand::has_cubic_to() const {
  return _internal_has_cubic_to();
}
inline void PathCommand::set_has_cubic_to() {
  _oneof_case_[0] = kCubicTo;
}
inline void PathCommand::clear_cubic_to() {
  if (_internal_has_cubic_to()) {
    if (GetArenaForAllocation() == nullptr) {
      delete cmd_.cubic_to_;
    }
    clear_has_cmd();
  }
}
inline ::uif::PCCubicCurve* PathCommand::release_cubic_to() {
  // @@protoc_insertion_point(field_release:uif.PathCommand.cubic_to)
  if (_internal_has_cubic_to()) {
    clear_has_cmd();
      ::uif::PCCubicCurve* temp = cmd_.cubic_to_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    cmd_.cubic_to_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::uif::PCCubicCurve& PathCommand::_internal_cubic_to() const {
  return _internal_has_cubic_to()
      ? *cmd_.cubic_to_
      : reinterpret_cast< ::uif::PCCubicCurve&>(::uif::_PCCubicCurve_default_instance_);
}
inline const ::uif::PCCubicCurve& PathCommand::cubic_to() const {
  // @@protoc_insertion_point(field_get:uif.PathCommand.cubic_to)
  return _internal_cubic_to();
}
inline ::uif::PCCubicCurve* PathCommand::unsafe_arena_release_cubic_to() {
  // @@protoc_insertion_point(field_unsafe_arena_release:uif.PathCommand.cubic_to)
  if (_internal_has_cubic_to()) {
    clear_has_cmd();
    ::uif::PCCubicCurve* temp = cmd_.cubic_to_;
    cmd_.cubic_to_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PathCommand::unsafe_arena_set_allocated_cubic_to(::uif::PCCubicCurve* cubic_to) {
  clear_cmd();
  if (cubic_to) {
    set_has_cubic_to();
    cmd_.cubic_to_ = cubic_to;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uif.PathCommand.cubic_to)
}
inline ::uif::PCCubicCurve* PathCommand::_internal_mutable_cubic_to() {
  if (!_internal_has_cubic_to()) {
    clear_cmd();
    set_has_cubic_to();
    cmd_.cubic_to_ = CreateMaybeMessage< ::uif::PCCubicCurve >(GetArenaForAllocation());
  }
  return cmd_.cubic_to_;
}
inline ::uif::PCCubicCurve* PathCommand::mutable_cubic_to() {
  ::uif::PCCubicCurve* _msg = _internal_mutable_cubic_to();
  // @@protoc_insertion_point(field_mutable:uif.PathCommand.cubic_to)
  return _msg;
}

// .uif.PCQuadraticCurve quad_to = 13;
inline bool PathCommand::_internal_has_quad_to() const {
  return cmd_case() == kQuadTo;
}
inline bool PathCommand::has_quad_to() const {
  return _internal_has_quad_to();
}
inline void PathCommand::set_has_quad_to() {
  _oneof_case_[0] = kQuadTo;
}
inline void PathCommand::clear_quad_to() {
  if (_internal_has_quad_to()) {
    if (GetArenaForAllocation() == nullptr) {
      delete cmd_.quad_to_;
    }
    clear_has_cmd();
  }
}
inline ::uif::PCQuadraticCurve* PathCommand::release_quad_to() {
  // @@protoc_insertion_point(field_release:uif.PathCommand.quad_to)
  if (_internal_has_quad_to()) {
    clear_has_cmd();
      ::uif::PCQuadraticCurve* temp = cmd_.quad_to_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    cmd_.quad_to_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::uif::PCQuadraticCurve& PathCommand::_internal_quad_to() const {
  return _internal_has_quad_to()
      ? *cmd_.quad_to_
      : reinterpret_cast< ::uif::PCQuadraticCurve&>(::uif::_PCQuadraticCurve_default_instance_);
}
inline const ::uif::PCQuadraticCurve& PathCommand::quad_to() const {
  // @@protoc_insertion_point(field_get:uif.PathCommand.quad_to)
  return _internal_quad_to();
}
inline ::uif::PCQuadraticCurve* PathCommand::unsafe_arena_release_quad_to() {
  // @@protoc_insertion_point(field_unsafe_arena_release:uif.PathCommand.quad_to)
  if (_internal_has_quad_to()) {
    clear_has_cmd();
    ::uif::PCQuadraticCurve* temp = cmd_.quad_to_;
    cmd_.quad_to_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PathCommand::unsafe_arena_set_allocated_quad_to(::uif::PCQuadraticCurve* quad_to) {
  clear_cmd();
  if (quad_to) {
    set_has_quad_to();
    cmd_.quad_to_ = quad_to;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uif.PathCommand.quad_to)
}
inline ::uif::PCQuadraticCurve* PathCommand::_internal_mutable_quad_to() {
  if (!_internal_has_quad_to()) {
    clear_cmd();
    set_has_quad_to();
    cmd_.quad_to_ = CreateMaybeMessage< ::uif::PCQuadraticCurve >(GetArenaForAllocation());
  }
  return cmd_.quad_to_;
}
inline ::uif::PCQuadraticCurve* PathCommand::mutable_quad_to() {
  ::uif::PCQuadraticCurve* _msg = _internal_mutable_quad_to();
  // @@protoc_insertion_point(field_mutable:uif.PathCommand.quad_to)
  return _msg;
}

// .uif.PCArc arc_to = 14;
inline bool PathCommand::_internal_has_arc_to() const {
  return cmd_case() == kArcTo;
}
inline bool PathCommand::has_arc_to() const {
  return _internal_has_arc_to();
}
inline void PathCommand::set_has_arc_to() {
  _oneof_case_[0] = kArcTo;
}
inline void PathCommand::clear_arc_to() {
  if (_internal_has_arc_to()) {
    if (GetArenaForAllocation() == nullptr) {
      delete cmd_.arc_to_;
    }
    clear_has_cmd();
  }
}
inline ::uif::PCArc* PathCommand::release_arc_to() {
  // @@protoc_insertion_point(field_release:uif.PathCommand.arc_to)
  if (_internal_has_arc_to()) {
    clear_has_cmd();
      ::uif::PCArc* temp = cmd_.arc_to_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    cmd_.arc_to_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::uif::PCArc& PathCommand::_internal_arc_to() const {
  return _internal_has_arc_to()
      ? *cmd_.arc_to_
      : reinterpret_cast< ::uif::PCArc&>(::uif::_PCArc_default_instance_);
}
inline const ::uif::PCArc& PathCommand::arc_to() const {
  // @@protoc_insertion_point(field_get:uif.PathCommand.arc_to)
  return _internal_arc_to();
}
inline ::uif::PCArc* PathCommand::unsafe_arena_release_arc_to() {
  // @@protoc_insertion_point(field_unsafe_arena_release:uif.PathCommand.arc_to)
  if (_internal_has_arc_to()) {
    clear_has_cmd();
    ::uif::PCArc* temp = cmd_.arc_to_;
    cmd_.arc_to_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PathCommand::unsafe_arena_set_allocated_arc_to(::uif::PCArc* arc_to) {
  clear_cmd();
  if (arc_to) {
    set_has_arc_to();
    cmd_.arc_to_ = arc_to;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uif.PathCommand.arc_to)
}
inline ::uif::PCArc* PathCommand::_internal_mutable_arc_to() {
  if (!_internal_has_arc_to()) {
    clear_cmd();
    set_has_arc_to();
    cmd_.arc_to_ = CreateMaybeMessage< ::uif::PCArc >(GetArenaForAllocation());
  }
  return cmd_.arc_to_;
}
inline ::uif::PCArc* PathCommand::mutable_arc_to() {
  ::uif::PCArc* _msg = _internal_mutable_arc_to();
  // @@protoc_insertion_point(field_mutable:uif.PathCommand.arc_to)
  return _msg;
}

inline bool PathCommand::has_cmd() const {
  return cmd_case() != CMD_NOT_SET;
}
inline void PathCommand::clear_has_cmd() {
  _oneof_case_[0] = CMD_NOT_SET;
}
inline PathCommand::CmdCase PathCommand::cmd_case() const {
  return PathCommand::CmdCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// PathNode

// repeated .uif.PathCommand commands = 1;
inline int PathNode::_internal_commands_size() const {
  return commands_.size();
}
inline int PathNode::commands_size() const {
  return _internal_commands_size();
}
inline void PathNode::clear_commands() {
  commands_.Clear();
}
inline ::uif::PathCommand* PathNode::mutable_commands(int index) {
  // @@protoc_insertion_point(field_mutable:uif.PathNode.commands)
  return commands_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::uif::PathCommand >*
PathNode::mutable_commands() {
  // @@protoc_insertion_point(field_mutable_list:uif.PathNode.commands)
  return &commands_;
}
inline const ::uif::PathCommand& PathNode::_internal_commands(int index) const {
  return commands_.Get(index);
}
inline const ::uif::PathCommand& PathNode::commands(int index) const {
  // @@protoc_insertion_point(field_get:uif.PathNode.commands)
  return _internal_commands(index);
}
inline ::uif::PathCommand* PathNode::_internal_add_commands() {
  return commands_.Add();
}
inline ::uif::PathCommand* PathNode::add_commands() {
  ::uif::PathCommand* _add = _internal_add_commands();
  // @@protoc_insertion_point(field_add:uif.PathNode.commands)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::uif::PathCommand >&
PathNode::commands() const {
  // @@protoc_insertion_point(field_list:uif.PathNode.commands)
  return commands_;
}

// bool is_filled = 2;
inline void PathNode::clear_is_filled() {
  is_filled_ = false;
}
inline bool PathNode::_internal_is_filled() const {
  return is_filled_;
}
inline bool PathNode::is_filled() const {
  // @@protoc_insertion_point(field_get:uif.PathNode.is_filled)
  return _internal_is_filled();
}
inline void PathNode::_internal_set_is_filled(bool value) {
  
  is_filled_ = value;
}
inline void PathNode::set_is_filled(bool value) {
  _internal_set_is_filled(value);
  // @@protoc_insertion_point(field_set:uif.PathNode.is_filled)
}

// .uif.Brush stroke = 3;
inline bool PathNode::_internal_has_stroke() const {
  return this != internal_default_instance() && stroke_ != nullptr;
}
inline bool PathNode::has_stroke() const {
  return _internal_has_stroke();
}
inline void PathNode::clear_stroke() {
  if (GetArenaForAllocation() == nullptr && stroke_ != nullptr) {
    delete stroke_;
  }
  stroke_ = nullptr;
}
inline const ::uif::Brush& PathNode::_internal_stroke() const {
  const ::uif::Brush* p = stroke_;
  return p != nullptr ? *p : reinterpret_cast<const ::uif::Brush&>(
      ::uif::_Brush_default_instance_);
}
inline const ::uif::Brush& PathNode::stroke() const {
  // @@protoc_insertion_point(field_get:uif.PathNode.stroke)
  return _internal_stroke();
}
inline void PathNode::unsafe_arena_set_allocated_stroke(
    ::uif::Brush* stroke) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stroke_);
  }
  stroke_ = stroke;
  if (stroke) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uif.PathNode.stroke)
}
inline ::uif::Brush* PathNode::release_stroke() {
  
  ::uif::Brush* temp = stroke_;
  stroke_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uif::Brush* PathNode::unsafe_arena_release_stroke() {
  // @@protoc_insertion_point(field_release:uif.PathNode.stroke)
  
  ::uif::Brush* temp = stroke_;
  stroke_ = nullptr;
  return temp;
}
inline ::uif::Brush* PathNode::_internal_mutable_stroke() {
  
  if (stroke_ == nullptr) {
    auto* p = CreateMaybeMessage<::uif::Brush>(GetArenaForAllocation());
    stroke_ = p;
  }
  return stroke_;
}
inline ::uif::Brush* PathNode::mutable_stroke() {
  ::uif::Brush* _msg = _internal_mutable_stroke();
  // @@protoc_insertion_point(field_mutable:uif.PathNode.stroke)
  return _msg;
}
inline void PathNode::set_allocated_stroke(::uif::Brush* stroke) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete stroke_;
  }
  if (stroke) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::uif::Brush>::GetOwningArena(stroke);
    if (message_arena != submessage_arena) {
      stroke = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stroke, submessage_arena);
    }
    
  } else {
    
  }
  stroke_ = stroke;
  // @@protoc_insertion_point(field_set_allocated:uif.PathNode.stroke)
}

// float stroke_width = 4;
inline void PathNode::clear_stroke_width() {
  stroke_width_ = 0;
}
inline float PathNode::_internal_stroke_width() const {
  return stroke_width_;
}
inline float PathNode::stroke_width() const {
  // @@protoc_insertion_point(field_get:uif.PathNode.stroke_width)
  return _internal_stroke_width();
}
inline void PathNode::_internal_set_stroke_width(float value) {
  
  stroke_width_ = value;
}
inline void PathNode::set_stroke_width(float value) {
  _internal_set_stroke_width(value);
  // @@protoc_insertion_point(field_set:uif.PathNode.stroke_width)
}

// -------------------------------------------------------------------

// EmptyNode

// -------------------------------------------------------------------

// ClipRectNode

// .uif.Rectangle rect = 1;
inline bool ClipRectNode::_internal_has_rect() const {
  return this != internal_default_instance() && rect_ != nullptr;
}
inline bool ClipRectNode::has_rect() const {
  return _internal_has_rect();
}
inline void ClipRectNode::clear_rect() {
  if (GetArenaForAllocation() == nullptr && rect_ != nullptr) {
    delete rect_;
  }
  rect_ = nullptr;
}
inline const ::uif::Rectangle& ClipRectNode::_internal_rect() const {
  const ::uif::Rectangle* p = rect_;
  return p != nullptr ? *p : reinterpret_cast<const ::uif::Rectangle&>(
      ::uif::_Rectangle_default_instance_);
}
inline const ::uif::Rectangle& ClipRectNode::rect() const {
  // @@protoc_insertion_point(field_get:uif.ClipRectNode.rect)
  return _internal_rect();
}
inline void ClipRectNode::unsafe_arena_set_allocated_rect(
    ::uif::Rectangle* rect) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rect_);
  }
  rect_ = rect;
  if (rect) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uif.ClipRectNode.rect)
}
inline ::uif::Rectangle* ClipRectNode::release_rect() {
  
  ::uif::Rectangle* temp = rect_;
  rect_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uif::Rectangle* ClipRectNode::unsafe_arena_release_rect() {
  // @@protoc_insertion_point(field_release:uif.ClipRectNode.rect)
  
  ::uif::Rectangle* temp = rect_;
  rect_ = nullptr;
  return temp;
}
inline ::uif::Rectangle* ClipRectNode::_internal_mutable_rect() {
  
  if (rect_ == nullptr) {
    auto* p = CreateMaybeMessage<::uif::Rectangle>(GetArenaForAllocation());
    rect_ = p;
  }
  return rect_;
}
inline ::uif::Rectangle* ClipRectNode::mutable_rect() {
  ::uif::Rectangle* _msg = _internal_mutable_rect();
  // @@protoc_insertion_point(field_mutable:uif.ClipRectNode.rect)
  return _msg;
}
inline void ClipRectNode::set_allocated_rect(::uif::Rectangle* rect) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rect_;
  }
  if (rect) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::uif::Rectangle>::GetOwningArena(rect);
    if (message_arena != submessage_arena) {
      rect = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rect, submessage_arena);
    }
    
  } else {
    
  }
  rect_ = rect;
  // @@protoc_insertion_point(field_set_allocated:uif.ClipRectNode.rect)
}

// -------------------------------------------------------------------

// EditCommand

// uint64 timestamp = 5;
inline void EditCommand::clear_timestamp() {
  timestamp_ = uint64_t{0u};
}
inline uint64_t EditCommand::_internal_timestamp() const {
  return timestamp_;
}
inline uint64_t EditCommand::timestamp() const {
  // @@protoc_insertion_point(field_get:uif.EditCommand.timestamp)
  return _internal_timestamp();
}
inline void EditCommand::_internal_set_timestamp(uint64_t value) {
  
  timestamp_ = value;
}
inline void EditCommand::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:uif.EditCommand.timestamp)
}

// string client_id = 4;
inline void EditCommand::clear_client_id() {
  client_id_.ClearToEmpty();
}
inline const std::string& EditCommand::client_id() const {
  // @@protoc_insertion_point(field_get:uif.EditCommand.client_id)
  return _internal_client_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EditCommand::set_client_id(ArgT0&& arg0, ArgT... args) {
 
 client_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:uif.EditCommand.client_id)
}
inline std::string* EditCommand::mutable_client_id() {
  std::string* _s = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:uif.EditCommand.client_id)
  return _s;
}
inline const std::string& EditCommand::_internal_client_id() const {
  return client_id_.Get();
}
inline void EditCommand::_internal_set_client_id(const std::string& value) {
  
  client_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EditCommand::_internal_mutable_client_id() {
  
  return client_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EditCommand::release_client_id() {
  // @@protoc_insertion_point(field_release:uif.EditCommand.client_id)
  return client_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EditCommand::set_allocated_client_id(std::string* client_id) {
  if (client_id != nullptr) {
    
  } else {
    
  }
  client_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), client_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (client_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    client_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:uif.EditCommand.client_id)
}

// .uif.EditCommand.EditKind kind = 1;
inline void EditCommand::clear_kind() {
  kind_ = 0;
}
inline ::uif::EditCommand_EditKind EditCommand::_internal_kind() const {
  return static_cast< ::uif::EditCommand_EditKind >(kind_);
}
inline ::uif::EditCommand_EditKind EditCommand::kind() const {
  // @@protoc_insertion_point(field_get:uif.EditCommand.kind)
  return _internal_kind();
}
inline void EditCommand::_internal_set_kind(::uif::EditCommand_EditKind value) {
  
  kind_ = value;
}
inline void EditCommand::set_kind(::uif::EditCommand_EditKind value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:uif.EditCommand.kind)
}

// uint64 parent_id = 2;
inline void EditCommand::clear_parent_id() {
  parent_id_ = uint64_t{0u};
}
inline uint64_t EditCommand::_internal_parent_id() const {
  return parent_id_;
}
inline uint64_t EditCommand::parent_id() const {
  // @@protoc_insertion_point(field_get:uif.EditCommand.parent_id)
  return _internal_parent_id();
}
inline void EditCommand::_internal_set_parent_id(uint64_t value) {
  
  parent_id_ = value;
}
inline void EditCommand::set_parent_id(uint64_t value) {
  _internal_set_parent_id(value);
  // @@protoc_insertion_point(field_set:uif.EditCommand.parent_id)
}

// uint64 object_id = 3;
inline void EditCommand::clear_object_id() {
  object_id_ = uint64_t{0u};
}
inline uint64_t EditCommand::_internal_object_id() const {
  return object_id_;
}
inline uint64_t EditCommand::object_id() const {
  // @@protoc_insertion_point(field_get:uif.EditCommand.object_id)
  return _internal_object_id();
}
inline void EditCommand::_internal_set_object_id(uint64_t value) {
  
  object_id_ = value;
}
inline void EditCommand::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:uif.EditCommand.object_id)
}

// .uif.RectangleNode rect = 10;
inline bool EditCommand::_internal_has_rect() const {
  return node_case() == kRect;
}
inline bool EditCommand::has_rect() const {
  return _internal_has_rect();
}
inline void EditCommand::set_has_rect() {
  _oneof_case_[0] = kRect;
}
inline void EditCommand::clear_rect() {
  if (_internal_has_rect()) {
    if (GetArenaForAllocation() == nullptr) {
      delete node_.rect_;
    }
    clear_has_node();
  }
}
inline ::uif::RectangleNode* EditCommand::release_rect() {
  // @@protoc_insertion_point(field_release:uif.EditCommand.rect)
  if (_internal_has_rect()) {
    clear_has_node();
      ::uif::RectangleNode* temp = node_.rect_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    node_.rect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::uif::RectangleNode& EditCommand::_internal_rect() const {
  return _internal_has_rect()
      ? *node_.rect_
      : reinterpret_cast< ::uif::RectangleNode&>(::uif::_RectangleNode_default_instance_);
}
inline const ::uif::RectangleNode& EditCommand::rect() const {
  // @@protoc_insertion_point(field_get:uif.EditCommand.rect)
  return _internal_rect();
}
inline ::uif::RectangleNode* EditCommand::unsafe_arena_release_rect() {
  // @@protoc_insertion_point(field_unsafe_arena_release:uif.EditCommand.rect)
  if (_internal_has_rect()) {
    clear_has_node();
    ::uif::RectangleNode* temp = node_.rect_;
    node_.rect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EditCommand::unsafe_arena_set_allocated_rect(::uif::RectangleNode* rect) {
  clear_node();
  if (rect) {
    set_has_rect();
    node_.rect_ = rect;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uif.EditCommand.rect)
}
inline ::uif::RectangleNode* EditCommand::_internal_mutable_rect() {
  if (!_internal_has_rect()) {
    clear_node();
    set_has_rect();
    node_.rect_ = CreateMaybeMessage< ::uif::RectangleNode >(GetArenaForAllocation());
  }
  return node_.rect_;
}
inline ::uif::RectangleNode* EditCommand::mutable_rect() {
  ::uif::RectangleNode* _msg = _internal_mutable_rect();
  // @@protoc_insertion_point(field_mutable:uif.EditCommand.rect)
  return _msg;
}

// .uif.TextNode text = 11;
inline bool EditCommand::_internal_has_text() const {
  return node_case() == kText;
}
inline bool EditCommand::has_text() const {
  return _internal_has_text();
}
inline void EditCommand::set_has_text() {
  _oneof_case_[0] = kText;
}
inline void EditCommand::clear_text() {
  if (_internal_has_text()) {
    if (GetArenaForAllocation() == nullptr) {
      delete node_.text_;
    }
    clear_has_node();
  }
}
inline ::uif::TextNode* EditCommand::release_text() {
  // @@protoc_insertion_point(field_release:uif.EditCommand.text)
  if (_internal_has_text()) {
    clear_has_node();
      ::uif::TextNode* temp = node_.text_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    node_.text_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::uif::TextNode& EditCommand::_internal_text() const {
  return _internal_has_text()
      ? *node_.text_
      : reinterpret_cast< ::uif::TextNode&>(::uif::_TextNode_default_instance_);
}
inline const ::uif::TextNode& EditCommand::text() const {
  // @@protoc_insertion_point(field_get:uif.EditCommand.text)
  return _internal_text();
}
inline ::uif::TextNode* EditCommand::unsafe_arena_release_text() {
  // @@protoc_insertion_point(field_unsafe_arena_release:uif.EditCommand.text)
  if (_internal_has_text()) {
    clear_has_node();
    ::uif::TextNode* temp = node_.text_;
    node_.text_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EditCommand::unsafe_arena_set_allocated_text(::uif::TextNode* text) {
  clear_node();
  if (text) {
    set_has_text();
    node_.text_ = text;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uif.EditCommand.text)
}
inline ::uif::TextNode* EditCommand::_internal_mutable_text() {
  if (!_internal_has_text()) {
    clear_node();
    set_has_text();
    node_.text_ = CreateMaybeMessage< ::uif::TextNode >(GetArenaForAllocation());
  }
  return node_.text_;
}
inline ::uif::TextNode* EditCommand::mutable_text() {
  ::uif::TextNode* _msg = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:uif.EditCommand.text)
  return _msg;
}

// .uif.PathNode path = 12;
inline bool EditCommand::_internal_has_path() const {
  return node_case() == kPath;
}
inline bool EditCommand::has_path() const {
  return _internal_has_path();
}
inline void EditCommand::set_has_path() {
  _oneof_case_[0] = kPath;
}
inline void EditCommand::clear_path() {
  if (_internal_has_path()) {
    if (GetArenaForAllocation() == nullptr) {
      delete node_.path_;
    }
    clear_has_node();
  }
}
inline ::uif::PathNode* EditCommand::release_path() {
  // @@protoc_insertion_point(field_release:uif.EditCommand.path)
  if (_internal_has_path()) {
    clear_has_node();
      ::uif::PathNode* temp = node_.path_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    node_.path_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::uif::PathNode& EditCommand::_internal_path() const {
  return _internal_has_path()
      ? *node_.path_
      : reinterpret_cast< ::uif::PathNode&>(::uif::_PathNode_default_instance_);
}
inline const ::uif::PathNode& EditCommand::path() const {
  // @@protoc_insertion_point(field_get:uif.EditCommand.path)
  return _internal_path();
}
inline ::uif::PathNode* EditCommand::unsafe_arena_release_path() {
  // @@protoc_insertion_point(field_unsafe_arena_release:uif.EditCommand.path)
  if (_internal_has_path()) {
    clear_has_node();
    ::uif::PathNode* temp = node_.path_;
    node_.path_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EditCommand::unsafe_arena_set_allocated_path(::uif::PathNode* path) {
  clear_node();
  if (path) {
    set_has_path();
    node_.path_ = path;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uif.EditCommand.path)
}
inline ::uif::PathNode* EditCommand::_internal_mutable_path() {
  if (!_internal_has_path()) {
    clear_node();
    set_has_path();
    node_.path_ = CreateMaybeMessage< ::uif::PathNode >(GetArenaForAllocation());
  }
  return node_.path_;
}
inline ::uif::PathNode* EditCommand::mutable_path() {
  ::uif::PathNode* _msg = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:uif.EditCommand.path)
  return _msg;
}

// .uif.EmptyNode empty = 20;
inline bool EditCommand::_internal_has_empty() const {
  return node_case() == kEmpty;
}
inline bool EditCommand::has_empty() const {
  return _internal_has_empty();
}
inline void EditCommand::set_has_empty() {
  _oneof_case_[0] = kEmpty;
}
inline void EditCommand::clear_empty() {
  if (_internal_has_empty()) {
    if (GetArenaForAllocation() == nullptr) {
      delete node_.empty_;
    }
    clear_has_node();
  }
}
inline ::uif::EmptyNode* EditCommand::release_empty() {
  // @@protoc_insertion_point(field_release:uif.EditCommand.empty)
  if (_internal_has_empty()) {
    clear_has_node();
      ::uif::EmptyNode* temp = node_.empty_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    node_.empty_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::uif::EmptyNode& EditCommand::_internal_empty() const {
  return _internal_has_empty()
      ? *node_.empty_
      : reinterpret_cast< ::uif::EmptyNode&>(::uif::_EmptyNode_default_instance_);
}
inline const ::uif::EmptyNode& EditCommand::empty() const {
  // @@protoc_insertion_point(field_get:uif.EditCommand.empty)
  return _internal_empty();
}
inline ::uif::EmptyNode* EditCommand::unsafe_arena_release_empty() {
  // @@protoc_insertion_point(field_unsafe_arena_release:uif.EditCommand.empty)
  if (_internal_has_empty()) {
    clear_has_node();
    ::uif::EmptyNode* temp = node_.empty_;
    node_.empty_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EditCommand::unsafe_arena_set_allocated_empty(::uif::EmptyNode* empty) {
  clear_node();
  if (empty) {
    set_has_empty();
    node_.empty_ = empty;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uif.EditCommand.empty)
}
inline ::uif::EmptyNode* EditCommand::_internal_mutable_empty() {
  if (!_internal_has_empty()) {
    clear_node();
    set_has_empty();
    node_.empty_ = CreateMaybeMessage< ::uif::EmptyNode >(GetArenaForAllocation());
  }
  return node_.empty_;
}
inline ::uif::EmptyNode* EditCommand::mutable_empty() {
  ::uif::EmptyNode* _msg = _internal_mutable_empty();
  // @@protoc_insertion_point(field_mutable:uif.EditCommand.empty)
  return _msg;
}

// .uif.ClipRectNode clip = 21;
inline bool EditCommand::_internal_has_clip() const {
  return node_case() == kClip;
}
inline bool EditCommand::has_clip() const {
  return _internal_has_clip();
}
inline void EditCommand::set_has_clip() {
  _oneof_case_[0] = kClip;
}
inline void EditCommand::clear_clip() {
  if (_internal_has_clip()) {
    if (GetArenaForAllocation() == nullptr) {
      delete node_.clip_;
    }
    clear_has_node();
  }
}
inline ::uif::ClipRectNode* EditCommand::release_clip() {
  // @@protoc_insertion_point(field_release:uif.EditCommand.clip)
  if (_internal_has_clip()) {
    clear_has_node();
      ::uif::ClipRectNode* temp = node_.clip_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    node_.clip_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::uif::ClipRectNode& EditCommand::_internal_clip() const {
  return _internal_has_clip()
      ? *node_.clip_
      : reinterpret_cast< ::uif::ClipRectNode&>(::uif::_ClipRectNode_default_instance_);
}
inline const ::uif::ClipRectNode& EditCommand::clip() const {
  // @@protoc_insertion_point(field_get:uif.EditCommand.clip)
  return _internal_clip();
}
inline ::uif::ClipRectNode* EditCommand::unsafe_arena_release_clip() {
  // @@protoc_insertion_point(field_unsafe_arena_release:uif.EditCommand.clip)
  if (_internal_has_clip()) {
    clear_has_node();
    ::uif::ClipRectNode* temp = node_.clip_;
    node_.clip_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EditCommand::unsafe_arena_set_allocated_clip(::uif::ClipRectNode* clip) {
  clear_node();
  if (clip) {
    set_has_clip();
    node_.clip_ = clip;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uif.EditCommand.clip)
}
inline ::uif::ClipRectNode* EditCommand::_internal_mutable_clip() {
  if (!_internal_has_clip()) {
    clear_node();
    set_has_clip();
    node_.clip_ = CreateMaybeMessage< ::uif::ClipRectNode >(GetArenaForAllocation());
  }
  return node_.clip_;
}
inline ::uif::ClipRectNode* EditCommand::mutable_clip() {
  ::uif::ClipRectNode* _msg = _internal_mutable_clip();
  // @@protoc_insertion_point(field_mutable:uif.EditCommand.clip)
  return _msg;
}

inline bool EditCommand::has_node() const {
  return node_case() != NODE_NOT_SET;
}
inline void EditCommand::clear_has_node() {
  _oneof_case_[0] = NODE_NOT_SET;
}
inline EditCommand::NodeCase EditCommand::node_case() const {
  return EditCommand::NodeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// EditReq

// repeated .uif.EditCommand commands = 2;
inline int EditReq::_internal_commands_size() const {
  return commands_.size();
}
inline int EditReq::commands_size() const {
  return _internal_commands_size();
}
inline void EditReq::clear_commands() {
  commands_.Clear();
}
inline ::uif::EditCommand* EditReq::mutable_commands(int index) {
  // @@protoc_insertion_point(field_mutable:uif.EditReq.commands)
  return commands_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::uif::EditCommand >*
EditReq::mutable_commands() {
  // @@protoc_insertion_point(field_mutable_list:uif.EditReq.commands)
  return &commands_;
}
inline const ::uif::EditCommand& EditReq::_internal_commands(int index) const {
  return commands_.Get(index);
}
inline const ::uif::EditCommand& EditReq::commands(int index) const {
  // @@protoc_insertion_point(field_get:uif.EditReq.commands)
  return _internal_commands(index);
}
inline ::uif::EditCommand* EditReq::_internal_add_commands() {
  return commands_.Add();
}
inline ::uif::EditCommand* EditReq::add_commands() {
  ::uif::EditCommand* _add = _internal_add_commands();
  // @@protoc_insertion_point(field_add:uif.EditReq.commands)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::uif::EditCommand >&
EditReq::commands() const {
  // @@protoc_insertion_point(field_list:uif.EditReq.commands)
  return commands_;
}

// -------------------------------------------------------------------

// EditResp

// -------------------------------------------------------------------

// GetEventsReq

// string client_id = 1;
inline void GetEventsReq::clear_client_id() {
  client_id_.ClearToEmpty();
}
inline const std::string& GetEventsReq::client_id() const {
  // @@protoc_insertion_point(field_get:uif.GetEventsReq.client_id)
  return _internal_client_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetEventsReq::set_client_id(ArgT0&& arg0, ArgT... args) {
 
 client_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:uif.GetEventsReq.client_id)
}
inline std::string* GetEventsReq::mutable_client_id() {
  std::string* _s = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:uif.GetEventsReq.client_id)
  return _s;
}
inline const std::string& GetEventsReq::_internal_client_id() const {
  return client_id_.Get();
}
inline void GetEventsReq::_internal_set_client_id(const std::string& value) {
  
  client_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetEventsReq::_internal_mutable_client_id() {
  
  return client_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetEventsReq::release_client_id() {
  // @@protoc_insertion_point(field_release:uif.GetEventsReq.client_id)
  return client_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetEventsReq::set_allocated_client_id(std::string* client_id) {
  if (client_id != nullptr) {
    
  } else {
    
  }
  client_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), client_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (client_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    client_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:uif.GetEventsReq.client_id)
}

// -------------------------------------------------------------------

// CloseEvent

// bool closed = 1;
inline void CloseEvent::clear_closed() {
  closed_ = false;
}
inline bool CloseEvent::_internal_closed() const {
  return closed_;
}
inline bool CloseEvent::closed() const {
  // @@protoc_insertion_point(field_get:uif.CloseEvent.closed)
  return _internal_closed();
}
inline void CloseEvent::_internal_set_closed(bool value) {
  
  closed_ = value;
}
inline void CloseEvent::set_closed(bool value) {
  _internal_set_closed(value);
  // @@protoc_insertion_point(field_set:uif.CloseEvent.closed)
}

// -------------------------------------------------------------------

// MouseEvent

// .uif.MouseButton button = 1;
inline void MouseEvent::clear_button() {
  button_ = 0;
}
inline ::uif::MouseButton MouseEvent::_internal_button() const {
  return static_cast< ::uif::MouseButton >(button_);
}
inline ::uif::MouseButton MouseEvent::button() const {
  // @@protoc_insertion_point(field_get:uif.MouseEvent.button)
  return _internal_button();
}
inline void MouseEvent::_internal_set_button(::uif::MouseButton value) {
  
  button_ = value;
}
inline void MouseEvent::set_button(::uif::MouseButton value) {
  _internal_set_button(value);
  // @@protoc_insertion_point(field_set:uif.MouseEvent.button)
}

// .uif.MouseState state = 2;
inline void MouseEvent::clear_state() {
  state_ = 0;
}
inline ::uif::MouseState MouseEvent::_internal_state() const {
  return static_cast< ::uif::MouseState >(state_);
}
inline ::uif::MouseState MouseEvent::state() const {
  // @@protoc_insertion_point(field_get:uif.MouseEvent.state)
  return _internal_state();
}
inline void MouseEvent::_internal_set_state(::uif::MouseState value) {
  
  state_ = value;
}
inline void MouseEvent::set_state(::uif::MouseState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:uif.MouseEvent.state)
}

// .uif.Point location = 3;
inline bool MouseEvent::_internal_has_location() const {
  return this != internal_default_instance() && location_ != nullptr;
}
inline bool MouseEvent::has_location() const {
  return _internal_has_location();
}
inline void MouseEvent::clear_location() {
  if (GetArenaForAllocation() == nullptr && location_ != nullptr) {
    delete location_;
  }
  location_ = nullptr;
}
inline const ::uif::Point& MouseEvent::_internal_location() const {
  const ::uif::Point* p = location_;
  return p != nullptr ? *p : reinterpret_cast<const ::uif::Point&>(
      ::uif::_Point_default_instance_);
}
inline const ::uif::Point& MouseEvent::location() const {
  // @@protoc_insertion_point(field_get:uif.MouseEvent.location)
  return _internal_location();
}
inline void MouseEvent::unsafe_arena_set_allocated_location(
    ::uif::Point* location) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(location_);
  }
  location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uif.MouseEvent.location)
}
inline ::uif::Point* MouseEvent::release_location() {
  
  ::uif::Point* temp = location_;
  location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uif::Point* MouseEvent::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:uif.MouseEvent.location)
  
  ::uif::Point* temp = location_;
  location_ = nullptr;
  return temp;
}
inline ::uif::Point* MouseEvent::_internal_mutable_location() {
  
  if (location_ == nullptr) {
    auto* p = CreateMaybeMessage<::uif::Point>(GetArenaForAllocation());
    location_ = p;
  }
  return location_;
}
inline ::uif::Point* MouseEvent::mutable_location() {
  ::uif::Point* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:uif.MouseEvent.location)
  return _msg;
}
inline void MouseEvent::set_allocated_location(::uif::Point* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete location_;
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::uif::Point>::GetOwningArena(location);
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:uif.MouseEvent.location)
}

// -------------------------------------------------------------------

// KeyboardEvent

// .uif.KeyState state = 1;
inline void KeyboardEvent::clear_state() {
  state_ = 0;
}
inline ::uif::KeyState KeyboardEvent::_internal_state() const {
  return static_cast< ::uif::KeyState >(state_);
}
inline ::uif::KeyState KeyboardEvent::state() const {
  // @@protoc_insertion_point(field_get:uif.KeyboardEvent.state)
  return _internal_state();
}
inline void KeyboardEvent::_internal_set_state(::uif::KeyState value) {
  
  state_ = value;
}
inline void KeyboardEvent::set_state(::uif::KeyState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:uif.KeyboardEvent.state)
}

// uint32 key_code = 2;
inline void KeyboardEvent::clear_key_code() {
  key_code_ = 0u;
}
inline uint32_t KeyboardEvent::_internal_key_code() const {
  return key_code_;
}
inline uint32_t KeyboardEvent::key_code() const {
  // @@protoc_insertion_point(field_get:uif.KeyboardEvent.key_code)
  return _internal_key_code();
}
inline void KeyboardEvent::_internal_set_key_code(uint32_t value) {
  
  key_code_ = value;
}
inline void KeyboardEvent::set_key_code(uint32_t value) {
  _internal_set_key_code(value);
  // @@protoc_insertion_point(field_set:uif.KeyboardEvent.key_code)
}

// -------------------------------------------------------------------

// TextHitEvent

// .uif.MouseEvent mouse = 1;
inline bool TextHitEvent::_internal_has_mouse() const {
  return this != internal_default_instance() && mouse_ != nullptr;
}
inline bool TextHitEvent::has_mouse() const {
  return _internal_has_mouse();
}
inline void TextHitEvent::clear_mouse() {
  if (GetArenaForAllocation() == nullptr && mouse_ != nullptr) {
    delete mouse_;
  }
  mouse_ = nullptr;
}
inline const ::uif::MouseEvent& TextHitEvent::_internal_mouse() const {
  const ::uif::MouseEvent* p = mouse_;
  return p != nullptr ? *p : reinterpret_cast<const ::uif::MouseEvent&>(
      ::uif::_MouseEvent_default_instance_);
}
inline const ::uif::MouseEvent& TextHitEvent::mouse() const {
  // @@protoc_insertion_point(field_get:uif.TextHitEvent.mouse)
  return _internal_mouse();
}
inline void TextHitEvent::unsafe_arena_set_allocated_mouse(
    ::uif::MouseEvent* mouse) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mouse_);
  }
  mouse_ = mouse;
  if (mouse) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uif.TextHitEvent.mouse)
}
inline ::uif::MouseEvent* TextHitEvent::release_mouse() {
  
  ::uif::MouseEvent* temp = mouse_;
  mouse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uif::MouseEvent* TextHitEvent::unsafe_arena_release_mouse() {
  // @@protoc_insertion_point(field_release:uif.TextHitEvent.mouse)
  
  ::uif::MouseEvent* temp = mouse_;
  mouse_ = nullptr;
  return temp;
}
inline ::uif::MouseEvent* TextHitEvent::_internal_mutable_mouse() {
  
  if (mouse_ == nullptr) {
    auto* p = CreateMaybeMessage<::uif::MouseEvent>(GetArenaForAllocation());
    mouse_ = p;
  }
  return mouse_;
}
inline ::uif::MouseEvent* TextHitEvent::mutable_mouse() {
  ::uif::MouseEvent* _msg = _internal_mutable_mouse();
  // @@protoc_insertion_point(field_mutable:uif.TextHitEvent.mouse)
  return _msg;
}
inline void TextHitEvent::set_allocated_mouse(::uif::MouseEvent* mouse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete mouse_;
  }
  if (mouse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::uif::MouseEvent>::GetOwningArena(mouse);
    if (message_arena != submessage_arena) {
      mouse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mouse, submessage_arena);
    }
    
  } else {
    
  }
  mouse_ = mouse;
  // @@protoc_insertion_point(field_set_allocated:uif.TextHitEvent.mouse)
}

// uint32 offset = 2;
inline void TextHitEvent::clear_offset() {
  offset_ = 0u;
}
inline uint32_t TextHitEvent::_internal_offset() const {
  return offset_;
}
inline uint32_t TextHitEvent::offset() const {
  // @@protoc_insertion_point(field_get:uif.TextHitEvent.offset)
  return _internal_offset();
}
inline void TextHitEvent::_internal_set_offset(uint32_t value) {
  
  offset_ = value;
}
inline void TextHitEvent::set_offset(uint32_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:uif.TextHitEvent.offset)
}

// uint32 length = 3;
inline void TextHitEvent::clear_length() {
  length_ = 0u;
}
inline uint32_t TextHitEvent::_internal_length() const {
  return length_;
}
inline uint32_t TextHitEvent::length() const {
  // @@protoc_insertion_point(field_get:uif.TextHitEvent.length)
  return _internal_length();
}
inline void TextHitEvent::_internal_set_length(uint32_t value) {
  
  length_ = value;
}
inline void TextHitEvent::set_length(uint32_t value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:uif.TextHitEvent.length)
}

// uint64 object_id = 4;
inline void TextHitEvent::clear_object_id() {
  object_id_ = uint64_t{0u};
}
inline uint64_t TextHitEvent::_internal_object_id() const {
  return object_id_;
}
inline uint64_t TextHitEvent::object_id() const {
  // @@protoc_insertion_point(field_get:uif.TextHitEvent.object_id)
  return _internal_object_id();
}
inline void TextHitEvent::_internal_set_object_id(uint64_t value) {
  
  object_id_ = value;
}
inline void TextHitEvent::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:uif.TextHitEvent.object_id)
}

// -------------------------------------------------------------------

// Event

// .uif.CloseEvent close = 10;
inline bool Event::_internal_has_close() const {
  return event_case() == kClose;
}
inline bool Event::has_close() const {
  return _internal_has_close();
}
inline void Event::set_has_close() {
  _oneof_case_[0] = kClose;
}
inline void Event::clear_close() {
  if (_internal_has_close()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.close_;
    }
    clear_has_event();
  }
}
inline ::uif::CloseEvent* Event::release_close() {
  // @@protoc_insertion_point(field_release:uif.Event.close)
  if (_internal_has_close()) {
    clear_has_event();
      ::uif::CloseEvent* temp = event_.close_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.close_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::uif::CloseEvent& Event::_internal_close() const {
  return _internal_has_close()
      ? *event_.close_
      : reinterpret_cast< ::uif::CloseEvent&>(::uif::_CloseEvent_default_instance_);
}
inline const ::uif::CloseEvent& Event::close() const {
  // @@protoc_insertion_point(field_get:uif.Event.close)
  return _internal_close();
}
inline ::uif::CloseEvent* Event::unsafe_arena_release_close() {
  // @@protoc_insertion_point(field_unsafe_arena_release:uif.Event.close)
  if (_internal_has_close()) {
    clear_has_event();
    ::uif::CloseEvent* temp = event_.close_;
    event_.close_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Event::unsafe_arena_set_allocated_close(::uif::CloseEvent* close) {
  clear_event();
  if (close) {
    set_has_close();
    event_.close_ = close;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uif.Event.close)
}
inline ::uif::CloseEvent* Event::_internal_mutable_close() {
  if (!_internal_has_close()) {
    clear_event();
    set_has_close();
    event_.close_ = CreateMaybeMessage< ::uif::CloseEvent >(GetArenaForAllocation());
  }
  return event_.close_;
}
inline ::uif::CloseEvent* Event::mutable_close() {
  ::uif::CloseEvent* _msg = _internal_mutable_close();
  // @@protoc_insertion_point(field_mutable:uif.Event.close)
  return _msg;
}

// .uif.MouseEvent mouse = 11;
inline bool Event::_internal_has_mouse() const {
  return event_case() == kMouse;
}
inline bool Event::has_mouse() const {
  return _internal_has_mouse();
}
inline void Event::set_has_mouse() {
  _oneof_case_[0] = kMouse;
}
inline void Event::clear_mouse() {
  if (_internal_has_mouse()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.mouse_;
    }
    clear_has_event();
  }
}
inline ::uif::MouseEvent* Event::release_mouse() {
  // @@protoc_insertion_point(field_release:uif.Event.mouse)
  if (_internal_has_mouse()) {
    clear_has_event();
      ::uif::MouseEvent* temp = event_.mouse_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.mouse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::uif::MouseEvent& Event::_internal_mouse() const {
  return _internal_has_mouse()
      ? *event_.mouse_
      : reinterpret_cast< ::uif::MouseEvent&>(::uif::_MouseEvent_default_instance_);
}
inline const ::uif::MouseEvent& Event::mouse() const {
  // @@protoc_insertion_point(field_get:uif.Event.mouse)
  return _internal_mouse();
}
inline ::uif::MouseEvent* Event::unsafe_arena_release_mouse() {
  // @@protoc_insertion_point(field_unsafe_arena_release:uif.Event.mouse)
  if (_internal_has_mouse()) {
    clear_has_event();
    ::uif::MouseEvent* temp = event_.mouse_;
    event_.mouse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Event::unsafe_arena_set_allocated_mouse(::uif::MouseEvent* mouse) {
  clear_event();
  if (mouse) {
    set_has_mouse();
    event_.mouse_ = mouse;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uif.Event.mouse)
}
inline ::uif::MouseEvent* Event::_internal_mutable_mouse() {
  if (!_internal_has_mouse()) {
    clear_event();
    set_has_mouse();
    event_.mouse_ = CreateMaybeMessage< ::uif::MouseEvent >(GetArenaForAllocation());
  }
  return event_.mouse_;
}
inline ::uif::MouseEvent* Event::mutable_mouse() {
  ::uif::MouseEvent* _msg = _internal_mutable_mouse();
  // @@protoc_insertion_point(field_mutable:uif.Event.mouse)
  return _msg;
}

// .uif.KeyboardEvent key = 12;
inline bool Event::_internal_has_key() const {
  return event_case() == kKey;
}
inline bool Event::has_key() const {
  return _internal_has_key();
}
inline void Event::set_has_key() {
  _oneof_case_[0] = kKey;
}
inline void Event::clear_key() {
  if (_internal_has_key()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.key_;
    }
    clear_has_event();
  }
}
inline ::uif::KeyboardEvent* Event::release_key() {
  // @@protoc_insertion_point(field_release:uif.Event.key)
  if (_internal_has_key()) {
    clear_has_event();
      ::uif::KeyboardEvent* temp = event_.key_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::uif::KeyboardEvent& Event::_internal_key() const {
  return _internal_has_key()
      ? *event_.key_
      : reinterpret_cast< ::uif::KeyboardEvent&>(::uif::_KeyboardEvent_default_instance_);
}
inline const ::uif::KeyboardEvent& Event::key() const {
  // @@protoc_insertion_point(field_get:uif.Event.key)
  return _internal_key();
}
inline ::uif::KeyboardEvent* Event::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:uif.Event.key)
  if (_internal_has_key()) {
    clear_has_event();
    ::uif::KeyboardEvent* temp = event_.key_;
    event_.key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Event::unsafe_arena_set_allocated_key(::uif::KeyboardEvent* key) {
  clear_event();
  if (key) {
    set_has_key();
    event_.key_ = key;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uif.Event.key)
}
inline ::uif::KeyboardEvent* Event::_internal_mutable_key() {
  if (!_internal_has_key()) {
    clear_event();
    set_has_key();
    event_.key_ = CreateMaybeMessage< ::uif::KeyboardEvent >(GetArenaForAllocation());
  }
  return event_.key_;
}
inline ::uif::KeyboardEvent* Event::mutable_key() {
  ::uif::KeyboardEvent* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:uif.Event.key)
  return _msg;
}

// .uif.TextHitEvent textHit = 13;
inline bool Event::_internal_has_texthit() const {
  return event_case() == kTextHit;
}
inline bool Event::has_texthit() const {
  return _internal_has_texthit();
}
inline void Event::set_has_texthit() {
  _oneof_case_[0] = kTextHit;
}
inline void Event::clear_texthit() {
  if (_internal_has_texthit()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.texthit_;
    }
    clear_has_event();
  }
}
inline ::uif::TextHitEvent* Event::release_texthit() {
  // @@protoc_insertion_point(field_release:uif.Event.textHit)
  if (_internal_has_texthit()) {
    clear_has_event();
      ::uif::TextHitEvent* temp = event_.texthit_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.texthit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::uif::TextHitEvent& Event::_internal_texthit() const {
  return _internal_has_texthit()
      ? *event_.texthit_
      : reinterpret_cast< ::uif::TextHitEvent&>(::uif::_TextHitEvent_default_instance_);
}
inline const ::uif::TextHitEvent& Event::texthit() const {
  // @@protoc_insertion_point(field_get:uif.Event.textHit)
  return _internal_texthit();
}
inline ::uif::TextHitEvent* Event::unsafe_arena_release_texthit() {
  // @@protoc_insertion_point(field_unsafe_arena_release:uif.Event.textHit)
  if (_internal_has_texthit()) {
    clear_has_event();
    ::uif::TextHitEvent* temp = event_.texthit_;
    event_.texthit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Event::unsafe_arena_set_allocated_texthit(::uif::TextHitEvent* texthit) {
  clear_event();
  if (texthit) {
    set_has_texthit();
    event_.texthit_ = texthit;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uif.Event.textHit)
}
inline ::uif::TextHitEvent* Event::_internal_mutable_texthit() {
  if (!_internal_has_texthit()) {
    clear_event();
    set_has_texthit();
    event_.texthit_ = CreateMaybeMessage< ::uif::TextHitEvent >(GetArenaForAllocation());
  }
  return event_.texthit_;
}
inline ::uif::TextHitEvent* Event::mutable_texthit() {
  ::uif::TextHitEvent* _msg = _internal_mutable_texthit();
  // @@protoc_insertion_point(field_mutable:uif.Event.textHit)
  return _msg;
}

inline bool Event::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void Event::clear_has_event() {
  _oneof_case_[0] = EVENT_NOT_SET;
}
inline Event::EventCase Event::event_case() const {
  return Event::EventCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GetServerPropertiesReq

// -------------------------------------------------------------------

// GetServerPropertiesResp

// uint32 window_width = 1;
inline void GetServerPropertiesResp::clear_window_width() {
  window_width_ = 0u;
}
inline uint32_t GetServerPropertiesResp::_internal_window_width() const {
  return window_width_;
}
inline uint32_t GetServerPropertiesResp::window_width() const {
  // @@protoc_insertion_point(field_get:uif.GetServerPropertiesResp.window_width)
  return _internal_window_width();
}
inline void GetServerPropertiesResp::_internal_set_window_width(uint32_t value) {
  
  window_width_ = value;
}
inline void GetServerPropertiesResp::set_window_width(uint32_t value) {
  _internal_set_window_width(value);
  // @@protoc_insertion_point(field_set:uif.GetServerPropertiesResp.window_width)
}

// uint32 window_height = 2;
inline void GetServerPropertiesResp::clear_window_height() {
  window_height_ = 0u;
}
inline uint32_t GetServerPropertiesResp::_internal_window_height() const {
  return window_height_;
}
inline uint32_t GetServerPropertiesResp::window_height() const {
  // @@protoc_insertion_point(field_get:uif.GetServerPropertiesResp.window_height)
  return _internal_window_height();
}
inline void GetServerPropertiesResp::_internal_set_window_height(uint32_t value) {
  
  window_height_ = value;
}
inline void GetServerPropertiesResp::set_window_height(uint32_t value) {
  _internal_set_window_height(value);
  // @@protoc_insertion_point(field_set:uif.GetServerPropertiesResp.window_height)
}

// -------------------------------------------------------------------

// SetClearColorReq

// uint32 color = 1;
inline void SetClearColorReq::clear_color() {
  color_ = 0u;
}
inline uint32_t SetClearColorReq::_internal_color() const {
  return color_;
}
inline uint32_t SetClearColorReq::color() const {
  // @@protoc_insertion_point(field_get:uif.SetClearColorReq.color)
  return _internal_color();
}
inline void SetClearColorReq::_internal_set_color(uint32_t value) {
  
  color_ = value;
}
inline void SetClearColorReq::set_color(uint32_t value) {
  _internal_set_color(value);
  // @@protoc_insertion_point(field_set:uif.SetClearColorReq.color)
}

// -------------------------------------------------------------------

// SetClearColorResp

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace uif

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::uif::EditCommand_EditKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::uif::EditCommand_EditKind>() {
  return ::uif::EditCommand_EditKind_descriptor();
}
template <> struct is_proto_enum< ::uif::FontStyle> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::uif::FontStyle>() {
  return ::uif::FontStyle_descriptor();
}
template <> struct is_proto_enum< ::uif::FontWeight> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::uif::FontWeight>() {
  return ::uif::FontWeight_descriptor();
}
template <> struct is_proto_enum< ::uif::FontStretch> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::uif::FontStretch>() {
  return ::uif::FontStretch_descriptor();
}
template <> struct is_proto_enum< ::uif::TextAlign> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::uif::TextAlign>() {
  return ::uif::TextAlign_descriptor();
}
template <> struct is_proto_enum< ::uif::ParagraphAlign> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::uif::ParagraphAlign>() {
  return ::uif::ParagraphAlign_descriptor();
}
template <> struct is_proto_enum< ::uif::PCBeginKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::uif::PCBeginKind>() {
  return ::uif::PCBeginKind_descriptor();
}
template <> struct is_proto_enum< ::uif::PCEndKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::uif::PCEndKind>() {
  return ::uif::PCEndKind_descriptor();
}
template <> struct is_proto_enum< ::uif::MouseButton> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::uif::MouseButton>() {
  return ::uif::MouseButton_descriptor();
}
template <> struct is_proto_enum< ::uif::MouseState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::uif::MouseState>() {
  return ::uif::MouseState_descriptor();
}
template <> struct is_proto_enum< ::uif::KeyState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::uif::KeyState>() {
  return ::uif::KeyState_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_uif_2eproto
